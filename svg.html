<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bézier Curve Editor - SVG</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          "Segoe UI",
          system-ui,
          -apple-system,
          sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        color: #e0e0e0;
      }

      .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        padding: 16px;
        gap: 16px;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 20px;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      h1 {
        font-size: 1.5rem;
        font-weight: 600;
        background: linear-gradient(90deg, #00d9ff, #8b5cf6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .toolbar {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .toolbar button {
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn-primary {
        background: linear-gradient(135deg, #00d9ff, #0099cc);
        color: #000;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 217, 255, 0.3);
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .btn-danger {
        background: linear-gradient(135deg, #ff4757, #c0392b);
        color: #fff;
      }

      .btn-danger:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);
      }

      .continuity-selector {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .continuity-selector label {
        font-size: 0.875rem;
        color: #a0a0a0;
      }

      .continuity-selector select {
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
        font-size: 0.875rem;
        cursor: pointer;
      }

      .main-content {
        flex: 1;
        display: flex;
        gap: 16px;
      }

      .canvas-container {
        flex: 1;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        overflow: hidden;
        position: relative;
      }

      #canvas {
        width: 100%;
        height: 100%;
        cursor: crosshair;
      }

      .sidebar {
        width: 280px;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 16px;
        overflow-y: auto;
      }

      .sidebar h3 {
        font-size: 0.875rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: #888;
        margin-bottom: 12px;
      }

      .info-box {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 16px;
        font-size: 0.8rem;
        line-height: 1.6;
      }

      .info-box code {
        background: rgba(0, 217, 255, 0.2);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: "Fira Code", monospace;
      }

      .segment-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .segment-item {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 10px;
        font-size: 0.8rem;
        border: 1px solid transparent;
        transition: all 0.2s ease;
      }

      .segment-item:hover {
        border-color: rgba(0, 217, 255, 0.3);
      }

      .segment-item.selected {
        border-color: #00d9ff;
        background: rgba(0, 217, 255, 0.1);
      }

      .junction-controls {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
      }

      .junction-btn {
        padding: 4px 8px;
        border: none;
        border-radius: 4px;
        font-size: 0.7rem;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
        transition: all 0.2s;
      }

      .junction-btn.active {
        background: #00d9ff;
        color: #000;
      }

      .junction-btn:hover:not(.active) {
        background: rgba(255, 255, 255, 0.2);
      }

      /* SVG styles */
      .curve-path {
        fill: none;
        stroke: #FFD700;
        stroke-width: 3;
        stroke-linecap: round;
      }

      .handle-line {
        stroke: rgba(139, 92, 246, 0.6);
        stroke-width: 1.5;
        stroke-dasharray: 4, 4;
      }

      .anchor-point {
        fill: #00d9ff;
        stroke: #fff;
        stroke-width: 2;
        cursor: move;
        transition: transform 0.1s ease;
        transform-box: fill-box;
        transform-origin: center;
      }

      .anchor-point:hover {
        transform: scale(1.3);
      }

      .control-point {
        fill: #8b5cf6;
        stroke: #fff;
        stroke-width: 2;
        cursor: move;
        transition: transform 0.1s ease;
        transform-box: fill-box;
        transform-origin: center;
      }

      .control-point:hover {
        transform: scale(1.3);
      }

      .anchor-point.endpoint-selected {
        fill: #ff9500;
        stroke: #fff;
        stroke-width: 3;
        animation: pulse 1s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
      }

      .point-label {
        font-size: 10px;
        fill: #888;
        pointer-events: none;
      }

      .instructions {
        position: absolute;
        bottom: 16px;
        left: 16px;
        background: rgba(0, 0, 0, 0.7);
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 0.75rem;
        color: #a0a0a0;
        max-width: 300px;
      }

      .instructions strong {
        color: #00d9ff;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>✨ Bézier Curve Editor (SVG)</h1>
        <div class="toolbar">
          <div class="continuity-selector">
            <label for="continuity">Junction Mode:</label>
            <select id="continuity">
              <option value="independent">Independent</option>
              <option value="c1" selected>C¹ (Tangent)</option>
              <option value="c2">C² (Curvature)</option>
            </select>
          </div>
          <button class="btn-secondary" id="exportBtn">Export JSON</button>
          <button class="btn-secondary" id="copyUrlBtn">Copy URL</button>
          <button class="btn-danger" id="clearBtn">Clear All</button>
        </div>
      </header>

      <div class="main-content">
        <div class="canvas-container">
          <svg id="canvas">
            <defs>
              <filter id="glow">
                <feGaussianBlur stdDeviation="2" result="coloredBlur" />
                <feMerge>
                  <feMergeNode in="coloredBlur" />
                  <feMergeNode in="SourceGraphic" />
                </feMerge>
              </filter>
            </defs>
            <g id="curves"></g>
            <g id="handles"></g>
            <g id="points"></g>
          </svg>
          <div class="instructions">
            <strong>Drag</strong> = move points freely<br />
            <strong>Ctrl+drag</strong> control point = maintain continuity<br />
            <strong>Shift+click</strong> = start new independent curve<br />
            <strong>Click endpoint</strong> then <strong>Ctrl+click</strong> canvas = extend<br />
            <strong>Ctrl+click</strong> anchor = delete · <strong>Space+drag</strong> = pan
          </div>
        </div>

        <div class="sidebar">
          <h3>Instructions</h3>
          <div class="info-box">
            <p><code>C⁰</code> - Points meet (always enforced)</p>
            <p><code>C¹</code> - Smooth tangent (direction matches)</p>
            <p><code>C²</code> - Smooth curvature (acceleration matches)</p>
          </div>

          <h3>Segments</h3>
          <div id="segmentList" class="segment-list">
            <div style="color: #666; font-size: 0.8rem">
              No segments yet. Click to start drawing!
            </div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import {
        createPoint,
        addPoints,
        subtractPoints,
        scalePoint,
        distance,
        lerp,
        cubicBezier,
        calculateC1Handle,
        calculateC2Handle,
        enforceC0,
        enforceC1,
        enforceC2,
      } from "./bezier-math.js";

      // ========================================================================
      // STATE
      // ========================================================================

      const state = {
        // Multiple independent curves - each curve is { segments: [], continuity: [] }
        curves: [],
        activeCurveIndex: -1, // Which curve is currently selected/being edited
        // Drawing state
        isDrawing: false,
        currentSegment: null, // Segment being drawn
        currentCurveIndex: -1, // Which curve we're adding to during drawing
        // Interaction state
        dragTarget: null, // { curveIndex, segmentIndex, pointType: 'p0'|'p1'|'p2'|'p3' }
        activeEndpoint: null, // { curveIndex, end: 'start' | 'end' } - which endpoint is selected
        potentialEndpointSelect: null, // Track potential endpoint selection for click vs drag
        didDrag: false, // Track if mouse moved during drag
        dragStartPos: null, // Starting position to detect drag vs click
        // Panning
        isPanning: false,
        panStart: null, // { x, y } - starting position for pan
        spacePressed: false, // Track if space is held for panning
        canvasFocused: true, // Whether canvas is focused - controls visibility of control points
      };

      // Helper to get active curve's segments
      function getActiveSegments() {
        if (state.activeCurveIndex >= 0 && state.activeCurveIndex < state.curves.length) {
          return state.curves[state.activeCurveIndex].segments;
        }
        return [];
      }

      // Helper to get active curve's continuity array
      function getActiveContinuity() {
        if (state.activeCurveIndex >= 0 && state.activeCurveIndex < state.curves.length) {
          return state.curves[state.activeCurveIndex].continuity;
        }
        return [];
      }

      // ========================================================================
      // URL SERIALIZATION
      // ========================================================================

      // Serialize a coordinate (use 'n' prefix for negatives to avoid conflict with '-')
      function serializeCoord(n) {
        const rounded = Math.round(n * 10) / 10; // 1 decimal precision
        if (rounded < 0) {
          return 'n' + Math.abs(rounded);
        }
        return String(rounded);
      }

      // Parse a coordinate (handle 'n' prefix for negatives)
      function parseCoord(c) {
        if (c.startsWith('n')) {
          return -parseFloat(c.slice(1));
        }
        return parseFloat(c);
      }

      // Serialize a point to "x~y"
      function serializePoint(p) {
        return serializeCoord(p.x) + '~' + serializeCoord(p.y);
      }

      // Parse a point from "x~y"
      function parsePoint(str) {
        const [x, y] = str.split('~').map(parseCoord);
        return { x, y };
      }

      // Serialize a segment to "x0~y0_x1~y1_x2~y2_x3~y3"
      function serializeSegment(seg) {
        return [seg.p0, seg.p1, seg.p2, seg.p3].map(serializePoint).join('_');
      }

      // Parse a segment from "x0~y0_x1~y1_x2~y2_x3~y3"
      function parseSegment(str) {
        const points = str.split('_').map(parsePoint);
        return { p0: points[0], p1: points[1], p2: points[2], p3: points[3] };
      }

      // Continuity mode to single letter
      function continuityToLetter(mode) {
        if (mode === 'c1') return 't';
        if (mode === 'c2') return 'c';
        return 'i'; // independent
      }

      // Single letter to continuity mode
      function letterToContinuity(letter) {
        if (letter === 't') return 'c1';
        if (letter === 'c') return 'c2';
        return 'independent';
      }

      // Serialize a single curve to string
      function serializeCurve(curve) {
        let result = '';
        curve.segments.forEach((seg, i) => {
          if (i > 0) {
            // Add continuity marker before this segment
            const cont = curve.continuity[i - 1] || 'independent';
            result += '-' + continuityToLetter(cont);
          }
          result += serializeSegment(seg);
        });
        return result;
      }

      // Parse a single curve from string
      function parseCurve(str) {
        const segments = [];
        const continuity = [];
        
        // Split by continuity markers (-i, -t, -c)
        const parts = str.split(/-(i|t|c)/);
        
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          if (!part) continue;
          
          if (part === 'i' || part === 't' || part === 'c') {
            continuity.push(letterToContinuity(part));
          } else {
            segments.push(parseSegment(part));
          }
        }
        return { segments, continuity };
      }

      // Serialize all curves to URL-safe string
      function serializeToURL() {
        if (state.curves.length === 0) return '';
        return state.curves.map(serializeCurve).join('!');
      }

      // Parse all curves from URL string
      function parseFromURL(str) {
        if (!str) return [];
        return str.split('!').filter(s => s).map(parseCurve);
      }

      // Update URL hash with current state
      function updateURLHash() {
        const serialized = serializeToURL();
        if (serialized) {
          window.history.replaceState(null, '', '#' + serialized);
        } else {
          window.history.replaceState(null, '', window.location.pathname);
        }
      }

      // Load curves from URL hash
      function loadFromURLHash() {
        const hash = window.location.hash.slice(1); // Remove '#'
        if (hash) {
          try {
            const curves = parseFromURL(hash);
            if (curves.length > 0) {
              state.curves = curves;
              return true;
            }
          } catch (e) {
            console.warn('Failed to parse URL hash:', e);
          }
        }
        return false;
      }

      // Debounce helper - only execute function after delay with no new calls
      function debounce(fn, delay) {
        let timeoutId = null;
        return function (...args) {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
          timeoutId = setTimeout(() => {
            fn.apply(this, args);
            timeoutId = null;
          }, delay);
        };
      }

      // Debounced version of updateURLHash - waits 300ms after last call
      const debouncedUpdateURLHash = debounce(updateURLHash, 300);

      // ========================================================================
      // NODE DELETION
      // ========================================================================

      function deleteNode(curveIndex, segmentIndex, pointType) {
        // Only anchor points (p0, p3) can be deleted
        if (pointType !== 'p0' && pointType !== 'p3') return;
        if (curveIndex < 0 || curveIndex >= state.curves.length) return;

        const curve = state.curves[curveIndex];
        const numSegments = curve.segments.length;
        if (numSegments === 0) return;

        if (numSegments === 1) {
          // Only one segment in curve - delete entire curve
          state.curves.splice(curveIndex, 1);
          // Adjust activeCurveIndex if needed
          if (state.activeCurveIndex >= state.curves.length) {
            state.activeCurveIndex = state.curves.length - 1;
          }
          return;
        }

        if (pointType === 'p0' && segmentIndex === 0) {
          // Deleting FIRST anchor - remove first segment
          curve.segments.shift();
          if (curve.continuity.length > 0) {
            curve.continuity.shift();
          }
          return;
        }

        if (pointType === 'p3' && segmentIndex === numSegments - 1) {
          // Deleting LAST anchor - remove last segment
          curve.segments.pop();
          if (curve.continuity.length > 0) {
            curve.continuity.pop();
          }
          return;
        }

        // Deleting a MIDDLE anchor - merge two adjacent segments
        let deleteIndex;
        if (pointType === 'p3') {
          deleteIndex = segmentIndex;
        } else {
          deleteIndex = segmentIndex - 1;
        }

        const seg1 = curve.segments[deleteIndex];
        const seg2 = curve.segments[deleteIndex + 1];

        const mergedSegment = {
          p0: { ...seg1.p0 },
          p1: { ...seg1.p1 },
          p2: { ...seg2.p2 },
          p3: { ...seg2.p3 },
        };

        curve.segments.splice(deleteIndex, 2, mergedSegment);
        if (curve.continuity.length > deleteIndex) {
          curve.continuity.splice(deleteIndex, 1);
        }
      }

      // ========================================================================
      // DOM REFERENCES
      // ========================================================================

      const svg = document.getElementById("canvas");
      const curvesGroup = document.getElementById("curves");
      const handlesGroup = document.getElementById("handles");
      const pointsGroup = document.getElementById("points");
      const continuitySelect = document.getElementById("continuity");
      const clearBtn = document.getElementById("clearBtn");
      const exportBtn = document.getElementById("exportBtn");
      const copyUrlBtn = document.getElementById("copyUrlBtn");
      const segmentList = document.getElementById("segmentList");

      // ========================================================================
      // UTILS
      // ========================================================================

      function getMousePosition(event) {
        const rect = svg.getBoundingClientRect();
        return createPoint(event.clientX - rect.left, event.clientY - rect.top);
      }

      function createSvgElement(tag, attrs = {}) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (const [key, value] of Object.entries(attrs)) {
          el.setAttribute(key, value);
        }
        return el;
      }

      // ========================================================================
      // RENDERING
      // ========================================================================

      function render() {
        // Clear all groups
        curvesGroup.innerHTML = "";
        handlesGroup.innerHTML = "";
        pointsGroup.innerHTML = "";

        // Draw all curves
        state.curves.forEach((curve, curveIndex) => {
          curve.segments.forEach((seg, segIndex) => {
            drawSegment(seg, curveIndex, segIndex, curve.segments.length);
          });
        });

        // Draw current segment being drawn
        if (state.currentSegment) {
          drawSegment(state.currentSegment, state.currentCurveIndex, -1, 0, true);
        }

        // Show/hide control points and handles based on canvas focus
        handlesGroup.style.display = state.canvasFocused ? '' : 'none';
        pointsGroup.style.display = state.canvasFocused ? '' : 'none';

        updateSegmentList();
        
        // Update URL hash to keep it in sync (but not during drawing)
        if (!state.isDrawing) {
          debouncedUpdateURLHash();
        }
      }

      function drawSegment(seg, curveIndex, segIndex, totalSegments, isCurrentlyDrawing = false) {
        // Draw curve path
        const pathData = `M ${seg.p0.x} ${seg.p0.y} C ${seg.p1.x} ${seg.p1.y}, ${seg.p2.x} ${seg.p2.y}, ${seg.p3.x} ${seg.p3.y}`;
        const path = createSvgElement("path", {
          d: pathData,
          class: "curve-path",
          filter: "url(#glow)",
        });
        if (isCurrentlyDrawing) {
          path.style.opacity = "0.6";
        }
        curvesGroup.appendChild(path);

        // Draw handle lines
        const handleLine1 = createSvgElement("line", {
          x1: seg.p0.x,
          y1: seg.p0.y,
          x2: seg.p1.x,
          y2: seg.p1.y,
          class: "handle-line",
        });
        handlesGroup.appendChild(handleLine1);

        const handleLine2 = createSvgElement("line", {
          x1: seg.p3.x,
          y1: seg.p3.y,
          x2: seg.p2.x,
          y2: seg.p2.y,
          class: "handle-line",
        });
        handlesGroup.appendChild(handleLine2);

        // Draw control points (circles)
        const cp1 = createSvgElement("circle", {
          cx: seg.p1.x,
          cy: seg.p1.y,
          r: 6,
          class: "control-point",
          "data-curve": curveIndex,
          "data-segment": segIndex,
          "data-point": "p1",
        });
        pointsGroup.appendChild(cp1);

        const cp2 = createSvgElement("circle", {
          cx: seg.p2.x,
          cy: seg.p2.y,
          r: 6,
          class: "control-point",
          "data-curve": curveIndex,
          "data-segment": segIndex,
          "data-point": "p2",
        });
        pointsGroup.appendChild(cp2);

        // Draw anchor points (rectangles)
        // Only draw p0 for first segment of a curve or when drawing
        if (segIndex === 0 || isCurrentlyDrawing) {
          const isStartSelected = state.activeEndpoint && 
            state.activeEndpoint.curveIndex === curveIndex && 
            state.activeEndpoint.end === 'start' && 
            segIndex === 0 && 
            !isCurrentlyDrawing;
          const anchor0 = createSvgElement("rect", {
            x: seg.p0.x - 6,
            y: seg.p0.y - 6,
            width: 12,
            height: 12,
            class: "anchor-point" + (isStartSelected ? " endpoint-selected" : ""),
            "data-curve": curveIndex,
            "data-segment": segIndex,
            "data-point": "p0",
          });
          pointsGroup.appendChild(anchor0);
        }

        // Always draw p3
        const isEndSelected = state.activeEndpoint && 
          state.activeEndpoint.curveIndex === curveIndex && 
          state.activeEndpoint.end === 'end' && 
          segIndex === totalSegments - 1 && 
          !isCurrentlyDrawing;
        const anchor3 = createSvgElement("rect", {
          x: seg.p3.x - 6,
          y: seg.p3.y - 6,
          width: 12,
          height: 12,
          class: "anchor-point" + (isEndSelected ? " endpoint-selected" : ""),
          "data-curve": curveIndex,
          "data-segment": segIndex,
          "data-point": "p3",
        });
        pointsGroup.appendChild(anchor3);
      }

      function updateSegmentList() {
        if (state.curves.length === 0) {
          segmentList.innerHTML =
            '<div style="color: #666; font-size: 0.8rem;">No segments yet. Click to start drawing!</div>';
          return;
        }

        let html = '';
        state.curves.forEach((curve, curveIndex) => {
          html += `<div style="margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;">
            <div style="color: #00d9ff; font-weight: bold; margin-bottom: 6px;">Curve ${curveIndex + 1}</div>`;
          
          curve.segments.forEach((seg, i) => {
            const junctionMode = i > 0 ? curve.continuity[i - 1] : null;
            html += `
              <div class="segment-item">
                <div><strong>Seg ${i + 1}</strong></div>
                <div style="color: #888;">P₀: (${Math.round(seg.p0.x)}, ${Math.round(seg.p0.y)})</div>
                <div style="color: #888;">P₃: (${Math.round(seg.p3.x)}, ${Math.round(seg.p3.y)})</div>
              </div>
            `;
          });
          html += '</div>';
        });

        segmentList.innerHTML = html;
      }

      // ========================================================================
      // CONTINUITY ENFORCEMENT
      // ========================================================================

      // Apply control point continuity when Ctrl+dragging
      // This mirrors the control point across the shared anchor
      function applyControlPointContinuity(curveIndex, segmentIndex, pointType, pos) {
        if (curveIndex < 0 || curveIndex >= state.curves.length) return;
        const curve = state.curves[curveIndex];
        
        // p1 is outgoing control from p0 (shared with previous segment's p3)
        // p2 is incoming control to p3 (shared with next segment's p0)
        if (pointType === 'p1' && segmentIndex > 0) {
          // Mirror p1 movement to previous segment's p2
          const seg = curve.segments[segmentIndex];
          const anchor = seg.p0; // This is also previous segment's p3
          const offset = subtractPoints(pos, anchor);
          curve.segments[segmentIndex - 1].p2 = subtractPoints(anchor, offset);
        }
        if (pointType === 'p2' && segmentIndex < curve.segments.length - 1) {
          // Mirror p2 movement to next segment's p1
          const seg = curve.segments[segmentIndex];
          const anchor = seg.p3; // This is also next segment's p0
          const offset = subtractPoints(pos, anchor);
          curve.segments[segmentIndex + 1].p1 = subtractPoints(anchor, offset);
        }
      }

      // ========================================================================
      // INTERACTION HANDLERS
      // ========================================================================

      function handleMouseDown(e) {
        const target = e.target;
        const pos = getMousePosition(e);

        // Reset drag tracking
        state.didDrag = false;
        state.dragStartPos = { ...pos };

        // Handle panning with space+drag or middle mouse button
        if (state.spacePressed || e.button === 1) {
          state.isPanning = true;
          state.panStart = { x: e.clientX, y: e.clientY };
          svg.style.cursor = 'grabbing';
          e.preventDefault();
          return;
        }

        // Check if clicking on an existing point
        if (
          target.classList.contains("anchor-point") ||
          target.classList.contains("control-point")
        ) {
          const curveIndex = parseInt(target.dataset.curve);
          const segIndex = parseInt(target.dataset.segment);
          const pointType = target.dataset.point;
          
          if (isNaN(curveIndex) || curveIndex < 0 || curveIndex >= state.curves.length) {
            return; // Invalid curve
          }
          
          const curve = state.curves[curveIndex];

          // Ctrl+Click on anchor = delete node
          if ((e.ctrlKey || e.metaKey) && target.classList.contains("anchor-point")) {
            deleteNode(curveIndex, segIndex, pointType);
            state.activeEndpoint = null;
            render();
            return;
          }

          // Check if clicking on an endpoint (first or last anchor of this curve)
          const isFirstAnchor = pointType === 'p0' && segIndex === 0;
          const isLastAnchor = pointType === 'p3' && segIndex === curve.segments.length - 1;

          // Start dragging - ALL points can be dragged including endpoints
          state.dragTarget = { curveIndex, segmentIndex: segIndex, pointType };
          
          // Track potential endpoint selection (will confirm on mouseUp if no drag)
          if (target.classList.contains("anchor-point") && (isFirstAnchor || isLastAnchor)) {
            state.potentialEndpointSelect = {
              curveIndex,
              segIndex,
              pointType,
              isFirst: isFirstAnchor,
            };
          } else {
            state.potentialEndpointSelect = null;
          }
          
          state.activeEndpoint = null; // Clear selection when starting to interact
          return;
        }

        // Clicking on canvas (not on a point)
        
        // Ctrl+click on canvas = extend from selected endpoint
        if ((e.ctrlKey || e.metaKey) && state.activeEndpoint) {
          const { curveIndex, end } = state.activeEndpoint;
          if (curveIndex >= 0 && curveIndex < state.curves.length) {
            const curve = state.curves[curveIndex];
            
            if (end === 'start') {
              // Add segment at the beginning of this curve
              const existingStart = curve.segments[0].p0;
              const newSegment = {
                p0: { ...pos },
                p1: { ...pos },
                p2: { ...existingStart },
                p3: { ...existingStart },
              };
              curve.segments.unshift(newSegment);
              curve.continuity.unshift('independent');
            } else {
              // Add segment at the end of this curve
              const existingEnd = curve.segments[curve.segments.length - 1].p3;
              const newSegment = {
                p0: { ...existingEnd },
                p1: { ...existingEnd },
                p2: { ...pos },
                p3: { ...pos },
              };
              curve.segments.push(newSegment);
              if (curve.segments.length > 1) {
                curve.continuity.push('independent');
              }
            }
            state.activeEndpoint = null;
            render();
            return;
          }
        }

        // Shift+click = start a completely new independent curve (or start first curve)
        if (e.shiftKey) {
          // Create a new curve
          const newCurveIndex = state.curves.length;
          state.curves.push({ segments: [], continuity: [] });
          state.currentCurveIndex = newCurveIndex;
          
          state.currentSegment = {
            p0: { ...pos },
            p1: { ...pos },
            p2: { ...pos },
            p3: { ...pos },
          };
          state.isDrawing = true;
          state.activeEndpoint = null;
          render();
          return;
        }

        // Regular click on canvas (no modifiers) = just clear endpoint selection
        // (points should only be created via Shift+click for new curves, or Ctrl+click to extend)
        state.activeEndpoint = null;
        render();
      }

      function handleMouseMove(e) {
        // Handle panning
        if (state.isPanning) {
          const dx = e.clientX - state.panStart.x;
          const dy = e.clientY - state.panStart.y;
          
          // Move all points in all curves
          state.curves.forEach(curve => {
            curve.segments.forEach(seg => {
              seg.p0.x += dx;
              seg.p0.y += dy;
              seg.p1.x += dx;
              seg.p1.y += dy;
              seg.p2.x += dx;
              seg.p2.y += dy;
              seg.p3.x += dx;
              seg.p3.y += dy;
            });
          });
          
          state.panStart = { x: e.clientX, y: e.clientY };
          render();
          return;
        }

        const pos = getMousePosition(e);

        // Handle dragging
        if (state.dragTarget) {
          const { curveIndex, segmentIndex, pointType } = state.dragTarget;
          
          if (curveIndex < 0 || curveIndex >= state.curves.length) {
            state.dragTarget = null;
            return;
          }
          
          const curve = state.curves[curveIndex];
          const seg = curve.segments[segmentIndex];
          
          if (!seg) {
            state.dragTarget = null;
            return;
          }

          // Track that we actually moved (for click vs drag detection)
          const dragDist = distance(pos, state.dragStartPos);
          if (dragDist > 3) {
            state.didDrag = true;
          }

          // For anchor points that are shared between segments WITHIN THE SAME CURVE
          if (pointType === "p0" && segmentIndex > 0) {
            // Also update previous segment's p3
            curve.segments[segmentIndex - 1].p3 = { ...pos };
          }
          if (pointType === "p3" && segmentIndex < curve.segments.length - 1) {
            // Also update next segment's p0
            curve.segments[segmentIndex + 1].p0 = { ...pos };
          }

          seg[pointType] = { ...pos };

          // Only apply continuity when Ctrl is held (explicit control)
          if ((e.ctrlKey || e.metaKey) && (pointType === "p1" || pointType === "p2")) {
            applyControlPointContinuity(curveIndex, segmentIndex, pointType, pos);
          }

          render();
          return;
        }

        // Handle drawing
        if (state.isDrawing && state.currentSegment) {
          // Update handles symmetrically while drawing
          const startPoint = state.currentSegment.p0;
          const handleOffset = subtractPoints(pos, startPoint);

          state.currentSegment.p1 = addPoints(startPoint, handleOffset);
          state.currentSegment.p2 = subtractPoints(
            pos,
            scalePoint(handleOffset, 0.3),
          );
          state.currentSegment.p3 = pos;

          render();
        }
      }

      function handleMouseUp(e) {
        // End panning
        if (state.isPanning) {
          state.isPanning = false;
          state.panStart = null;
          svg.style.cursor = state.spacePressed ? 'grab' : 'crosshair';
          return;
        }

        if (state.dragTarget) {
          // If we didn't drag much and it was an endpoint, select it
          if (state.potentialEndpointSelect && !state.didDrag) {
            const { curveIndex, isFirst } = state.potentialEndpointSelect;
            const clickedEndpoint = { curveIndex, end: isFirst ? 'start' : 'end' };
            
            // Toggle selection
            if (state.activeEndpoint && 
                state.activeEndpoint.curveIndex === clickedEndpoint.curveIndex && 
                state.activeEndpoint.end === clickedEndpoint.end) {
              state.activeEndpoint = null;
            } else {
              state.activeEndpoint = clickedEndpoint;
            }
            render();
          }
          
          state.dragTarget = null;
          state.potentialEndpointSelect = null;
          state.didDrag = false;
          state.dragStartPos = null;
          return;
        }

        // Finish placing current segment
        if (state.isDrawing && state.currentSegment) {
          const curveIndex = state.currentCurveIndex;
          
          if (curveIndex >= 0 && curveIndex < state.curves.length) {
            const curve = state.curves[curveIndex];
            
            // New segments are independent by default
            if (curve.segments.length > 0) {
              curve.continuity.push('independent');
            }

            curve.segments.push(state.currentSegment);
          }

          state.currentSegment = null;
          state.isDrawing = false;

          render();
        }
      }

      function handleDoubleClick(e) {
        // Finish the current path
        state.isDrawing = false;
        state.currentSegment = null;
        render();
      }

      function handleClear() {
        state.curves = [];
        state.activeCurveIndex = -1;
        state.isDrawing = false;
        state.currentSegment = null;
        state.currentCurveIndex = -1;
        state.dragTarget = null;
        state.activeEndpoint = null;
        state.potentialEndpointSelect = null;
        state.didDrag = false;
        state.dragStartPos = null;
        state.isPanning = false;
        state.panStart = null;
        render();
      }

      function handleExport() {
        const data = {
          curves: state.curves,
        };
        const json = JSON.stringify(data, null, 2);

        // Create download
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "bezier-curves.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      function handleCopyUrl() {
        const serialized = serializeToURL();
        if (!serialized) {
          alert('No curves to share!');
          return;
        }
        const fullUrl = window.location.origin + window.location.pathname + '#' + serialized;
        navigator.clipboard.writeText(fullUrl).then(() => {
          // Temporarily change button text to show success
          const originalText = copyUrlBtn.textContent;
          copyUrlBtn.textContent = 'Copied!';
          setTimeout(() => {
            copyUrlBtn.textContent = originalText;
          }, 1500);
        }).catch(err => {
          console.error('Failed to copy URL:', err);
          // Fallback: show in a prompt
          prompt('Copy this URL:', fullUrl);
        });
      }

      // ========================================================================
      // EVENT LISTENERS
      // ========================================================================

      svg.addEventListener("mousedown", handleMouseDown);
      svg.addEventListener("mousemove", handleMouseMove);
      svg.addEventListener("mouseup", handleMouseUp);
      svg.addEventListener("dblclick", handleDoubleClick);
      svg.addEventListener("mouseleave", () => {
        if (state.dragTarget) {
          state.dragTarget = null;
        }
      });

      clearBtn.addEventListener("click", handleClear);
      exportBtn.addEventListener("click", handleExport);
      copyUrlBtn.addEventListener("click", handleCopyUrl);

      // Keyboard events for space+drag panning and escape for focus mode
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !state.spacePressed) {
          state.spacePressed = true;
          svg.style.cursor = 'grab';
          e.preventDefault();
        }
        // Escape key enters focus mode (hides control points)
        if (e.code === 'Escape' && state.canvasFocused) {
          state.canvasFocused = false;
          render();
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
          state.spacePressed = false;
          if (!state.isPanning) {
            svg.style.cursor = 'crosshair';
          }
        }
      });

      // Prevent context menu on middle click
      svg.addEventListener('contextmenu', (e) => {
        if (e.button === 1) e.preventDefault();
      });

      // Load from URL hash if present
      loadFromURLHash();

      // Canvas focus/unfocus - hide control points when clicking outside canvas
      document.addEventListener('mousedown', (e) => {
        const clickedOnCanvas = svg.contains(e.target);
        if (clickedOnCanvas && !state.canvasFocused) {
          state.canvasFocused = true;
          render();
        } else if (!clickedOnCanvas && state.canvasFocused) {
          // Check if click is on a toolbar button - don't unfocus for those
          const isToolbarClick = e.target.closest('.toolbar') || e.target.closest('.sidebar');
          if (!isToolbarClick) {
            state.canvasFocused = false;
            render();
          }
        }
      });

      // Initial render
      render();
    </script>
  </body>
</html>
