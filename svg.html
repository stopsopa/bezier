<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bézier Curve Editor - SVG</title>
    <link rel="stylesheet" href="common.css" />
    <style>
      /* SVG Editor Theme: Cyan/Purple */
      :root {
        --theme-primary: #00d9ff;
        --theme-primary-rgb: 0, 217, 255;
        --theme-gradient: linear-gradient(90deg, #00d9ff, #8b5cf6);
        --theme-btn-primary: linear-gradient(135deg, #00d9ff, #0099cc);
        --theme-btn-primary-text: #000;
        /* Curve color: #FFD700 gold */
      }

      /* SVG-specific styles */
      .curve-path {
        fill: none;
        stroke: #ffd700;
        stroke-width: 3;
        stroke-linecap: round;
      }

      .handle-line {
        stroke: rgba(139, 92, 246, 0.6);
        stroke-width: 1.5;
        stroke-dasharray: 4, 4;
      }

      .anchor-point {
        fill: #00d9ff;
        stroke: #fff;
        stroke-width: 2;
        cursor: move;
        transition: transform 0.1s ease;
        transform-box: fill-box;
        transform-origin: center;
      }

      .anchor-point:hover {
        transform: scale(1.3);
      }

      .control-point {
        fill: #8b5cf6;
        stroke: #fff;
        stroke-width: 2;
        cursor: move;
        transition: transform 0.1s ease;
        transform-box: fill-box;
        transform-origin: center;
      }

      .control-point:hover {
        transform: scale(1.3);
      }

      .anchor-point.endpoint-selected {
        fill: #ff9500;
        stroke: #fff;
        stroke-width: 3;
        animation: pulse 1s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.6;
        }
      }

      .point-label {
        font-size: 10px;
        fill: #888;
        pointer-events: none;
      }

      .instructions {
        position: absolute;
        bottom: 16px;
        left: 16px;
        background: rgba(0, 0, 0, 0.7);
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 0.75rem;
        color: #a0a0a0;
        max-width: 300px;
      }

      .instructions strong {
        color: #00d9ff;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>✨ Bézier Curve Editor (SVG)</h1>
        <div class="toolbar">
          <div class="nav-links">
            <span>View in:</span>
            <a href="canvas.html" class="nav-link" id="navCanvas">Canvas</a>
            <a href="html.html" class="nav-link" id="navHtml">HTML</a>
            <a href="webgl.html" class="nav-link" id="navWebgl">WebGL</a>
            <a href="webgpu.html" class="nav-link" id="navWebgpu">WebGPU</a>
          </div>
          <div class="continuity-selector">
            <label for="continuity">Junction Mode:</label>
            <select id="continuity">
              <option value="independent">Independent</option>
              <option value="c1" selected>C¹ (Tangent)</option>
              <option value="c2">C² (Curvature)</option>
            </select>
          </div>
          <button class="btn-secondary" id="exportBtn">Export JSON</button>
          <button class="btn-secondary" id="copyUrlBtn">Copy URL</button>
          <button class="btn-danger" id="clearBtn">Clear All</button>
        </div>
      </header>

      <div class="main-content">
        <div class="canvas-container">
          <svg id="canvas">
            <defs>
              <filter id="glow">
                <feGaussianBlur stdDeviation="2" result="coloredBlur" />
                <feMerge>
                  <feMergeNode in="coloredBlur" />
                  <feMergeNode in="SourceGraphic" />
                </feMerge>
              </filter>
            </defs>
            <g id="curves"></g>
            <g id="handles"></g>
            <g id="points"></g>
          </svg>
          <div class="instructions">
            <strong>Drag</strong> = move points freely<br />
            <strong>Ctrl+drag</strong> control point = maintain continuity<br />
            <strong>Shift+click</strong> = start new independent curve<br />
            <strong>Click endpoint</strong> then <strong>Ctrl+click</strong> canvas = extend<br />
            <strong>Ctrl+click</strong> anchor = delete · <strong>Space+drag</strong> = pan
          </div>
        </div>

        <div class="sidebar">
          <h3>Instructions</h3>
          <div class="info-box">
            <p><code>C⁰</code> - Points meet (always enforced)</p>
            <p><code>C¹</code> - Smooth tangent (direction matches)</p>
            <p><code>C²</code> - Smooth curvature (acceleration matches)</p>
          </div>

          <h3>Segments</h3>
          <div id="segmentList" class="segment-list">
            <div style="color: #666; font-size: 0.8rem">No segments yet. Click to start drawing!</div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import {
        createPoint,
        addPoints,
        subtractPoints,
        scalePoint,
        distance,
        lerp,
        cubicBezier,
        calculateC1Handle,
        calculateC2Handle,
        enforceC0,
        enforceC1,
        enforceC2,
      } from "./bezier-math.js";
      import { serializeCurves, parseCurvesFromURL, deleteNodeFromCurves, debounce } from "./common.js";

      // ========================================================================
      // STATE
      // ========================================================================

      const state = {
        // Multiple independent curves - each curve is { segments: [], continuity: [] }
        curves: [],
        activeCurveIndex: -1, // Which curve is currently selected/being edited
        // Drawing state
        isDrawing: false,
        currentSegment: null, // Segment being drawn
        currentCurveIndex: -1, // Which curve we're adding to during drawing
        // Interaction state
        dragTarget: null, // { curveIndex, segmentIndex, pointType: 'p0'|'p1'|'p2'|'p3' }
        activeEndpoint: null, // { curveIndex, end: 'start' | 'end' } - which endpoint is selected
        potentialEndpointSelect: null, // Track potential endpoint selection for click vs drag
        didDrag: false, // Track if mouse moved during drag
        dragStartPos: null, // Starting position to detect drag vs click
        // Panning
        isPanning: false,
        panStart: null, // { x, y } - starting position for pan
        spacePressed: false, // Track if space is held for panning
        canvasFocused: true, // Whether canvas is focused - controls visibility of control points
      };

      // Helper to get active curve's segments
      function getActiveSegments() {
        if (state.activeCurveIndex >= 0 && state.activeCurveIndex < state.curves.length) {
          return state.curves[state.activeCurveIndex].segments;
        }
        return [];
      }

      // Helper to get active curve's continuity array
      function getActiveContinuity() {
        if (state.activeCurveIndex >= 0 && state.activeCurveIndex < state.curves.length) {
          return state.curves[state.activeCurveIndex].continuity;
        }
        return [];
      }

      // ========================================================================
      // URL SERIALIZATION (uses common.js)
      // ========================================================================

      function updateURLHash() {
        const serialized = serializeCurves(state.curves);
        if (serialized) {
          window.history.replaceState(null, "", "#" + serialized);
        } else {
          window.history.replaceState(null, "", window.location.pathname);
        }
        updateNavLinks();
      }

      function updateNavLinks() {
        const hash = serializeCurves(state.curves);
        const hashStr = hash ? "#" + hash : "";
        document.getElementById("navCanvas").href = "canvas.html" + hashStr;
        document.getElementById("navHtml").href = "html.html" + hashStr;
        document.getElementById("navWebgl").href = "webgl.html" + hashStr;
        document.getElementById("navWebgpu").href = "webgpu.html" + hashStr;
      }

      function loadFromURLHash() {
        const hash = window.location.hash.slice(1);
        if (hash) {
          try {
            const curves = parseCurvesFromURL(hash);
            if (curves.length > 0) {
              state.curves = curves;
              return true;
            }
          } catch (e) {
            console.warn("Failed to parse URL hash:", e);
          }
        }
        return false;
      }

      const debouncedUpdateURLHash = debounce(updateURLHash, 300);

      // ========================================================================
      // NODE DELETION (uses common.js)
      // ========================================================================

      function deleteNode(curveIndex, segmentIndex, pointType) {
        const result = deleteNodeFromCurves(state.curves, state.activeCurveIndex, curveIndex, segmentIndex, pointType);
        state.curves = result.curves;
        state.activeCurveIndex = result.activeCurveIndex;
      }

      // ========================================================================
      // DOM REFERENCES
      // ========================================================================

      const svg = document.getElementById("canvas");
      const curvesGroup = document.getElementById("curves");
      const handlesGroup = document.getElementById("handles");
      const pointsGroup = document.getElementById("points");
      const continuitySelect = document.getElementById("continuity");
      const clearBtn = document.getElementById("clearBtn");
      const exportBtn = document.getElementById("exportBtn");
      const copyUrlBtn = document.getElementById("copyUrlBtn");
      const segmentList = document.getElementById("segmentList");

      // ========================================================================
      // UTILS
      // ========================================================================

      function getMousePosition(event) {
        const rect = svg.getBoundingClientRect();
        return createPoint(event.clientX - rect.left, event.clientY - rect.top);
      }

      function createSvgElement(tag, attrs = {}) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (const [key, value] of Object.entries(attrs)) {
          el.setAttribute(key, value);
        }
        return el;
      }

      // ========================================================================
      // RENDERING
      // ========================================================================

      function render() {
        // Clear all groups
        curvesGroup.innerHTML = "";
        handlesGroup.innerHTML = "";
        pointsGroup.innerHTML = "";

        // Draw all curves
        state.curves.forEach((curve, curveIndex) => {
          curve.segments.forEach((seg, segIndex) => {
            drawSegment(seg, curveIndex, segIndex, curve.segments.length);
          });
        });

        // Draw current segment being drawn
        if (state.currentSegment) {
          drawSegment(state.currentSegment, state.currentCurveIndex, -1, 0, true);
        }

        // Show/hide control points and handles based on canvas focus
        handlesGroup.style.display = state.canvasFocused ? "" : "none";
        pointsGroup.style.display = state.canvasFocused ? "" : "none";

        updateSegmentList();

        // Update URL hash to keep it in sync (but not during drawing)
        if (!state.isDrawing) {
          debouncedUpdateURLHash();
        }
      }

      function drawSegment(seg, curveIndex, segIndex, totalSegments, isCurrentlyDrawing = false) {
        // Draw curve path
        const pathData = `M ${seg.p0.x} ${seg.p0.y} C ${seg.p1.x} ${seg.p1.y}, ${seg.p2.x} ${seg.p2.y}, ${seg.p3.x} ${seg.p3.y}`;
        const path = createSvgElement("path", {
          d: pathData,
          class: "curve-path",
          filter: "url(#glow)",
        });
        if (isCurrentlyDrawing) {
          path.style.opacity = "0.6";
        }
        curvesGroup.appendChild(path);

        // Draw handle lines
        const handleLine1 = createSvgElement("line", {
          x1: seg.p0.x,
          y1: seg.p0.y,
          x2: seg.p1.x,
          y2: seg.p1.y,
          class: "handle-line",
        });
        handlesGroup.appendChild(handleLine1);

        const handleLine2 = createSvgElement("line", {
          x1: seg.p3.x,
          y1: seg.p3.y,
          x2: seg.p2.x,
          y2: seg.p2.y,
          class: "handle-line",
        });
        handlesGroup.appendChild(handleLine2);

        // Draw control points (circles)
        const cp1 = createSvgElement("circle", {
          cx: seg.p1.x,
          cy: seg.p1.y,
          r: 6,
          class: "control-point",
          "data-curve": curveIndex,
          "data-segment": segIndex,
          "data-point": "p1",
        });
        pointsGroup.appendChild(cp1);

        const cp2 = createSvgElement("circle", {
          cx: seg.p2.x,
          cy: seg.p2.y,
          r: 6,
          class: "control-point",
          "data-curve": curveIndex,
          "data-segment": segIndex,
          "data-point": "p2",
        });
        pointsGroup.appendChild(cp2);

        // Draw anchor points (rectangles)
        // Only draw p0 for first segment of a curve or when drawing
        if (segIndex === 0 || isCurrentlyDrawing) {
          const isStartSelected =
            state.activeEndpoint &&
            state.activeEndpoint.curveIndex === curveIndex &&
            state.activeEndpoint.end === "start" &&
            segIndex === 0 &&
            !isCurrentlyDrawing;
          const anchor0 = createSvgElement("rect", {
            x: seg.p0.x - 6,
            y: seg.p0.y - 6,
            width: 12,
            height: 12,
            class: "anchor-point" + (isStartSelected ? " endpoint-selected" : ""),
            "data-curve": curveIndex,
            "data-segment": segIndex,
            "data-point": "p0",
          });
          pointsGroup.appendChild(anchor0);
        }

        // Always draw p3
        const isEndSelected =
          state.activeEndpoint &&
          state.activeEndpoint.curveIndex === curveIndex &&
          state.activeEndpoint.end === "end" &&
          segIndex === totalSegments - 1 &&
          !isCurrentlyDrawing;
        const anchor3 = createSvgElement("rect", {
          x: seg.p3.x - 6,
          y: seg.p3.y - 6,
          width: 12,
          height: 12,
          class: "anchor-point" + (isEndSelected ? " endpoint-selected" : ""),
          "data-curve": curveIndex,
          "data-segment": segIndex,
          "data-point": "p3",
        });
        pointsGroup.appendChild(anchor3);
      }

      function updateSegmentList() {
        if (state.curves.length === 0) {
          segmentList.innerHTML =
            '<div style="color: #666; font-size: 0.8rem;">No segments yet. Click to start drawing!</div>';
          return;
        }

        let html = "";
        state.curves.forEach((curve, curveIndex) => {
          html += `<div style="margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;">
            <div style="color: #00d9ff; font-weight: bold; margin-bottom: 6px;">Curve ${curveIndex + 1}</div>`;

          curve.segments.forEach((seg, i) => {
            const junctionMode = i > 0 ? curve.continuity[i - 1] : null;
            html += `
              <div class="segment-item">
                <div><strong>Seg ${i + 1}</strong></div>
                <div style="color: #888;">P₀: (${Math.round(seg.p0.x)}, ${Math.round(seg.p0.y)})</div>
                <div style="color: #888;">P₃: (${Math.round(seg.p3.x)}, ${Math.round(seg.p3.y)})</div>
              </div>
            `;
          });
          html += "</div>";
        });

        segmentList.innerHTML = html;
      }

      // ========================================================================
      // CONTINUITY ENFORCEMENT
      // ========================================================================

      // Apply control point continuity when Ctrl+dragging
      // This mirrors the control point across the shared anchor
      function applyControlPointContinuity(curveIndex, segmentIndex, pointType, pos) {
        if (curveIndex < 0 || curveIndex >= state.curves.length) return;
        const curve = state.curves[curveIndex];

        // p1 is outgoing control from p0 (shared with previous segment's p3)
        // p2 is incoming control to p3 (shared with next segment's p0)
        if (pointType === "p1" && segmentIndex > 0) {
          // Mirror p1 movement to previous segment's p2
          const seg = curve.segments[segmentIndex];
          const anchor = seg.p0; // This is also previous segment's p3
          const offset = subtractPoints(pos, anchor);
          curve.segments[segmentIndex - 1].p2 = subtractPoints(anchor, offset);
        }
        if (pointType === "p2" && segmentIndex < curve.segments.length - 1) {
          // Mirror p2 movement to next segment's p1
          const seg = curve.segments[segmentIndex];
          const anchor = seg.p3; // This is also next segment's p0
          const offset = subtractPoints(pos, anchor);
          curve.segments[segmentIndex + 1].p1 = subtractPoints(anchor, offset);
        }
      }

      // ========================================================================
      // INTERACTION HANDLERS
      // ========================================================================

      function handleMouseDown(e) {
        const target = e.target;
        const pos = getMousePosition(e);

        // Reset drag tracking
        state.didDrag = false;
        state.dragStartPos = { ...pos };

        // Handle panning with space+drag or middle mouse button
        if (state.spacePressed || e.button === 1) {
          state.isPanning = true;
          state.panStart = { x: e.clientX, y: e.clientY };
          svg.style.cursor = "grabbing";
          e.preventDefault();
          return;
        }

        // Check if clicking on an existing point
        if (target.classList.contains("anchor-point") || target.classList.contains("control-point")) {
          const curveIndex = parseInt(target.dataset.curve);
          const segIndex = parseInt(target.dataset.segment);
          const pointType = target.dataset.point;

          if (isNaN(curveIndex) || curveIndex < 0 || curveIndex >= state.curves.length) {
            return; // Invalid curve
          }

          const curve = state.curves[curveIndex];

          // Ctrl+Click on anchor = delete node
          if ((e.ctrlKey || e.metaKey) && target.classList.contains("anchor-point")) {
            deleteNode(curveIndex, segIndex, pointType);
            state.activeEndpoint = null;
            render();
            return;
          }

          // Check if clicking on an endpoint (first or last anchor of this curve)
          const isFirstAnchor = pointType === "p0" && segIndex === 0;
          const isLastAnchor = pointType === "p3" && segIndex === curve.segments.length - 1;

          // Start dragging - ALL points can be dragged including endpoints
          state.dragTarget = { curveIndex, segmentIndex: segIndex, pointType };

          // Track potential endpoint selection (will confirm on mouseUp if no drag)
          if (target.classList.contains("anchor-point") && (isFirstAnchor || isLastAnchor)) {
            state.potentialEndpointSelect = {
              curveIndex,
              segIndex,
              pointType,
              isFirst: isFirstAnchor,
            };
          } else {
            state.potentialEndpointSelect = null;
          }

          state.activeEndpoint = null; // Clear selection when starting to interact
          return;
        }

        // Clicking on canvas (not on a point)

        // Ctrl+click on canvas = extend from selected endpoint
        if ((e.ctrlKey || e.metaKey) && state.activeEndpoint) {
          const { curveIndex, end } = state.activeEndpoint;
          if (curveIndex >= 0 && curveIndex < state.curves.length) {
            const curve = state.curves[curveIndex];

            if (end === "start") {
              // Add segment at the beginning of this curve
              const existingStart = curve.segments[0].p0;
              const newSegment = {
                p0: { ...pos },
                p1: { ...pos },
                p2: { ...existingStart },
                p3: { ...existingStart },
              };
              curve.segments.unshift(newSegment);
              curve.continuity.unshift("independent");
            } else {
              // Add segment at the end of this curve
              const existingEnd = curve.segments[curve.segments.length - 1].p3;
              const newSegment = {
                p0: { ...existingEnd },
                p1: { ...existingEnd },
                p2: { ...pos },
                p3: { ...pos },
              };
              curve.segments.push(newSegment);
              if (curve.segments.length > 1) {
                curve.continuity.push("independent");
              }
            }
            state.activeEndpoint = null;
            render();
            return;
          }
        }

        // Shift+click = start a completely new independent curve (or start first curve)
        if (e.shiftKey) {
          // Create a new curve
          const newCurveIndex = state.curves.length;
          state.curves.push({ segments: [], continuity: [] });
          state.currentCurveIndex = newCurveIndex;

          state.currentSegment = {
            p0: { ...pos },
            p1: { ...pos },
            p2: { ...pos },
            p3: { ...pos },
          };
          state.isDrawing = true;
          state.activeEndpoint = null;
          render();
          return;
        }

        // Regular click on canvas (no modifiers) = just clear endpoint selection
        // (points should only be created via Shift+click for new curves, or Ctrl+click to extend)
        state.activeEndpoint = null;
        render();
      }

      function handleMouseMove(e) {
        // Handle panning
        if (state.isPanning) {
          const dx = e.clientX - state.panStart.x;
          const dy = e.clientY - state.panStart.y;

          // Move all points in all curves
          state.curves.forEach((curve) => {
            curve.segments.forEach((seg) => {
              seg.p0.x += dx;
              seg.p0.y += dy;
              seg.p1.x += dx;
              seg.p1.y += dy;
              seg.p2.x += dx;
              seg.p2.y += dy;
              seg.p3.x += dx;
              seg.p3.y += dy;
            });
          });

          state.panStart = { x: e.clientX, y: e.clientY };
          render();
          return;
        }

        const pos = getMousePosition(e);

        // Handle dragging
        if (state.dragTarget) {
          const { curveIndex, segmentIndex, pointType } = state.dragTarget;

          if (curveIndex < 0 || curveIndex >= state.curves.length) {
            state.dragTarget = null;
            return;
          }

          const curve = state.curves[curveIndex];
          const seg = curve.segments[segmentIndex];

          if (!seg) {
            state.dragTarget = null;
            return;
          }

          // Track that we actually moved (for click vs drag detection)
          const dragDist = distance(pos, state.dragStartPos);
          if (dragDist > 3) {
            state.didDrag = true;
          }

          // For anchor points that are shared between segments WITHIN THE SAME CURVE
          if (pointType === "p0" && segmentIndex > 0) {
            // Also update previous segment's p3
            curve.segments[segmentIndex - 1].p3 = { ...pos };
          }
          if (pointType === "p3" && segmentIndex < curve.segments.length - 1) {
            // Also update next segment's p0
            curve.segments[segmentIndex + 1].p0 = { ...pos };
          }

          seg[pointType] = { ...pos };

          // Only apply continuity when Ctrl is held (explicit control)
          if ((e.ctrlKey || e.metaKey) && (pointType === "p1" || pointType === "p2")) {
            applyControlPointContinuity(curveIndex, segmentIndex, pointType, pos);
          }

          render();
          return;
        }

        // Handle drawing
        if (state.isDrawing && state.currentSegment) {
          // Update handles symmetrically while drawing
          const startPoint = state.currentSegment.p0;
          const handleOffset = subtractPoints(pos, startPoint);

          state.currentSegment.p1 = addPoints(startPoint, handleOffset);
          state.currentSegment.p2 = subtractPoints(pos, scalePoint(handleOffset, 0.3));
          state.currentSegment.p3 = pos;

          render();
        }
      }

      function handleMouseUp(e) {
        // End panning
        if (state.isPanning) {
          state.isPanning = false;
          state.panStart = null;
          svg.style.cursor = state.spacePressed ? "grab" : "crosshair";
          return;
        }

        if (state.dragTarget) {
          // If we didn't drag much and it was an endpoint, select it
          if (state.potentialEndpointSelect && !state.didDrag) {
            const { curveIndex, isFirst } = state.potentialEndpointSelect;
            const clickedEndpoint = { curveIndex, end: isFirst ? "start" : "end" };

            // Toggle selection
            if (
              state.activeEndpoint &&
              state.activeEndpoint.curveIndex === clickedEndpoint.curveIndex &&
              state.activeEndpoint.end === clickedEndpoint.end
            ) {
              state.activeEndpoint = null;
            } else {
              state.activeEndpoint = clickedEndpoint;
            }
            render();
          }

          state.dragTarget = null;
          state.potentialEndpointSelect = null;
          state.didDrag = false;
          state.dragStartPos = null;
          return;
        }

        // Finish placing current segment
        if (state.isDrawing && state.currentSegment) {
          const curveIndex = state.currentCurveIndex;

          if (curveIndex >= 0 && curveIndex < state.curves.length) {
            const curve = state.curves[curveIndex];

            // New segments are independent by default
            if (curve.segments.length > 0) {
              curve.continuity.push("independent");
            }

            curve.segments.push(state.currentSegment);
          }

          state.currentSegment = null;
          state.isDrawing = false;

          render();
        }
      }

      function handleDoubleClick(e) {
        // Finish the current path
        state.isDrawing = false;
        state.currentSegment = null;
        render();
      }

      function handleClear() {
        state.curves = [];
        state.activeCurveIndex = -1;
        state.isDrawing = false;
        state.currentSegment = null;
        state.currentCurveIndex = -1;
        state.dragTarget = null;
        state.activeEndpoint = null;
        state.potentialEndpointSelect = null;
        state.didDrag = false;
        state.dragStartPos = null;
        state.isPanning = false;
        state.panStart = null;
        render();
      }

      function handleExport() {
        const data = {
          curves: state.curves,
        };
        const json = JSON.stringify(data, null, 2);

        // Create download
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "bezier-curves.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      function handleCopyUrl() {
        const serialized = serializeToURL();
        if (!serialized) {
          alert("No curves to share!");
          return;
        }
        const fullUrl = window.location.origin + window.location.pathname + "#" + serialized;
        navigator.clipboard
          .writeText(fullUrl)
          .then(() => {
            // Temporarily change button text to show success
            const originalText = copyUrlBtn.textContent;
            copyUrlBtn.textContent = "Copied!";
            setTimeout(() => {
              copyUrlBtn.textContent = originalText;
            }, 1500);
          })
          .catch((err) => {
            console.error("Failed to copy URL:", err);
            // Fallback: show in a prompt
            prompt("Copy this URL:", fullUrl);
          });
      }

      // ========================================================================
      // EVENT LISTENERS
      // ========================================================================

      svg.addEventListener("mousedown", handleMouseDown);
      svg.addEventListener("mousemove", handleMouseMove);
      svg.addEventListener("mouseup", handleMouseUp);
      svg.addEventListener("dblclick", handleDoubleClick);
      svg.addEventListener("mouseleave", () => {
        if (state.dragTarget) {
          state.dragTarget = null;
        }
      });

      clearBtn.addEventListener("click", handleClear);
      exportBtn.addEventListener("click", handleExport);
      copyUrlBtn.addEventListener("click", handleCopyUrl);

      // Keyboard events for space+drag panning and escape for focus mode
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" && !state.spacePressed) {
          state.spacePressed = true;
          svg.style.cursor = "grab";
          e.preventDefault();
        }
        // Escape key enters focus mode (hides control points)
        if (e.code === "Escape" && state.canvasFocused) {
          state.canvasFocused = false;
          render();
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          state.spacePressed = false;
          if (!state.isPanning) {
            svg.style.cursor = "crosshair";
          }
        }
      });

      // Prevent context menu on middle click
      svg.addEventListener("contextmenu", (e) => {
        if (e.button === 1) e.preventDefault();
      });

      // Load from URL hash if present
      loadFromURLHash();
      updateNavLinks();

      // Canvas focus/unfocus - hide control points when clicking outside canvas
      document.addEventListener("mousedown", (e) => {
        const clickedOnCanvas = svg.contains(e.target);
        if (clickedOnCanvas && !state.canvasFocused) {
          state.canvasFocused = true;
          render();
        } else if (!clickedOnCanvas && state.canvasFocused) {
          // Check if click is on a toolbar button - don't unfocus for those
          const isToolbarClick = e.target.closest(".toolbar") || e.target.closest(".sidebar");
          if (!isToolbarClick) {
            state.canvasFocused = false;
            render();
          }
        }
      });

      // Initial render
      render();
    </script>
    <script
      src="https://cdn.jsdelivr.net/gh/MarketingPipeline/GitHub-Ribbon-Web-Component/dist/github-ribbon-wc.min.js"
      defer
    ></script>

    <github-ribbon link="https://github.com/stopsopa/bezier" type="right" color="#679d2c" side="bottom-right"
      >Fork me on GitHub</github-ribbon
    >
  </body>
</html>
