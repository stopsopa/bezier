<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bézier Curve Editor - SVG</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          "Segoe UI",
          system-ui,
          -apple-system,
          sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        color: #e0e0e0;
      }

      .container {
        display: flex;
        flex-direction: column;
        height: 100vh;
        padding: 16px;
        gap: 16px;
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 20px;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      h1 {
        font-size: 1.5rem;
        font-weight: 600;
        background: linear-gradient(90deg, #00d9ff, #8b5cf6);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .toolbar {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .toolbar button {
        padding: 8px 16px;
        border: none;
        border-radius: 8px;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .btn-primary {
        background: linear-gradient(135deg, #00d9ff, #0099cc);
        color: #000;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 217, 255, 0.3);
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.15);
      }

      .btn-danger {
        background: linear-gradient(135deg, #ff4757, #c0392b);
        color: #fff;
      }

      .btn-danger:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);
      }

      .continuity-selector {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .continuity-selector label {
        font-size: 0.875rem;
        color: #a0a0a0;
      }

      .continuity-selector select {
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
        font-size: 0.875rem;
        cursor: pointer;
      }

      .main-content {
        flex: 1;
        display: flex;
        gap: 16px;
      }

      .canvas-container {
        flex: 1;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        overflow: hidden;
        position: relative;
      }

      #canvas {
        width: 100%;
        height: 100%;
        cursor: crosshair;
      }

      .sidebar {
        width: 280px;
        background: rgba(255, 255, 255, 0.05);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 16px;
        overflow-y: auto;
      }

      .sidebar h3 {
        font-size: 0.875rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: #888;
        margin-bottom: 12px;
      }

      .info-box {
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        padding: 12px;
        margin-bottom: 16px;
        font-size: 0.8rem;
        line-height: 1.6;
      }

      .info-box code {
        background: rgba(0, 217, 255, 0.2);
        padding: 2px 6px;
        border-radius: 4px;
        font-family: "Fira Code", monospace;
      }

      .segment-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .segment-item {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        padding: 10px;
        font-size: 0.8rem;
        border: 1px solid transparent;
        transition: all 0.2s ease;
      }

      .segment-item:hover {
        border-color: rgba(0, 217, 255, 0.3);
      }

      .segment-item.selected {
        border-color: #00d9ff;
        background: rgba(0, 217, 255, 0.1);
      }

      .junction-controls {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 8px;
      }

      .junction-btn {
        padding: 4px 8px;
        border: none;
        border-radius: 4px;
        font-size: 0.7rem;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
        transition: all 0.2s;
      }

      .junction-btn.active {
        background: #00d9ff;
        color: #000;
      }

      .junction-btn:hover:not(.active) {
        background: rgba(255, 255, 255, 0.2);
      }

      /* SVG styles */
      .curve-path {
        fill: none;
        stroke: #00d9ff;
        stroke-width: 3;
        stroke-linecap: round;
      }

      .handle-line {
        stroke: rgba(139, 92, 246, 0.6);
        stroke-width: 1.5;
        stroke-dasharray: 4, 4;
      }

      .anchor-point {
        fill: #00d9ff;
        stroke: #fff;
        stroke-width: 2;
        cursor: move;
        transition: transform 0.1s ease;
        transform-box: fill-box;
        transform-origin: center;
      }

      .anchor-point:hover {
        transform: scale(1.3);
      }

      .control-point {
        fill: #8b5cf6;
        stroke: #fff;
        stroke-width: 2;
        cursor: move;
        transition: transform 0.1s ease;
        transform-box: fill-box;
        transform-origin: center;
      }

      .control-point:hover {
        transform: scale(1.3);
      }

      .anchor-point.endpoint-selected {
        fill: #ff9500;
        stroke: #fff;
        stroke-width: 3;
        animation: pulse 1s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
      }

      .point-label {
        font-size: 10px;
        fill: #888;
        pointer-events: none;
      }

      .instructions {
        position: absolute;
        bottom: 16px;
        left: 16px;
        background: rgba(0, 0, 0, 0.7);
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 0.75rem;
        color: #a0a0a0;
        max-width: 300px;
      }

      .instructions strong {
        color: #00d9ff;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>✨ Bézier Curve Editor (SVG)</h1>
        <div class="toolbar">
          <div class="continuity-selector">
            <label for="continuity">Junction Mode:</label>
            <select id="continuity">
              <option value="independent">Independent</option>
              <option value="c1" selected>C¹ (Tangent)</option>
              <option value="c2">C² (Curvature)</option>
            </select>
          </div>
          <button class="btn-secondary" id="exportBtn">Export JSON</button>
          <button class="btn-danger" id="clearBtn">Clear All</button>
        </div>
      </header>

      <div class="main-content">
        <div class="canvas-container">
          <svg id="canvas">
            <defs>
              <filter id="glow">
                <feGaussianBlur stdDeviation="2" result="coloredBlur" />
                <feMerge>
                  <feMergeNode in="coloredBlur" />
                  <feMergeNode in="SourceGraphic" />
                </feMerge>
              </filter>
            </defs>
            <g id="curves"></g>
            <g id="handles"></g>
            <g id="points"></g>
          </svg>
          <div class="instructions">
            <strong>Drag</strong> = move points freely<br />
            <strong>Ctrl+drag</strong> control point = maintain continuity<br />
            <strong>Shift+click</strong> = start new independent curve<br />
            <strong>Click endpoint</strong> then <strong>Ctrl+click</strong> canvas = extend<br />
            <strong>Ctrl+click</strong> anchor = delete · <strong>Space+drag</strong> = pan
          </div>
        </div>

        <div class="sidebar">
          <h3>Instructions</h3>
          <div class="info-box">
            <p><code>C⁰</code> - Points meet (always enforced)</p>
            <p><code>C¹</code> - Smooth tangent (direction matches)</p>
            <p><code>C²</code> - Smooth curvature (acceleration matches)</p>
          </div>

          <h3>Segments</h3>
          <div id="segmentList" class="segment-list">
            <div style="color: #666; font-size: 0.8rem">
              No segments yet. Click to start drawing!
            </div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import {
        createPoint,
        addPoints,
        subtractPoints,
        scalePoint,
        distance,
        lerp,
        cubicBezier,
        calculateC1Handle,
        calculateC2Handle,
        enforceC0,
        enforceC1,
        enforceC2,
      } from "./bezier-math.js";

      // ========================================================================
      // STATE
      // ========================================================================

      const state = {
        // Multiple curves support - each curve is { segments: [], continuity: [] }
        curves: [],
        activeCurveIndex: -1, // Which curve is currently selected/being edited
        // Flat references for backward compatibility
        segments: [], // Array of { p0, p1, p2, p3 }
        continuity: [], // Array of 'independent' | 'c1' | 'c2' per junction
        isDrawing: false,
        currentSegment: null, // Segment being drawn
        dragTarget: null, // { segmentIndex, pointType: 'p0'|'p1'|'p2'|'p3' }
        selectedJunction: null, // Index of selected junction
        // New state for enhancements
        activeEndpoint: null, // 'start' | 'end' | null - which end is selected for extension
        potentialEndpointSelect: null, // Track potential endpoint selection for click vs drag
        didDrag: false, // Track if mouse moved during drag
        dragStartPos: null, // Starting position to detect drag vs click
        isPanning: false,
        panStart: null, // { x, y } - starting position for pan
        viewBox: { x: 0, y: 0, width: 0, height: 0 },
        spacePressed: false, // Track if space is held for panning
      };

      // ========================================================================
      // NODE DELETION
      // ========================================================================

      function deleteNode(segmentIndex, pointType) {
        // Only anchor points (p0, p3) can be deleted
        if (pointType !== 'p0' && pointType !== 'p3') return;

        const numSegments = state.segments.length;
        if (numSegments === 0) return;

        // Determine which anchor is being deleted
        // p0 of segment 0 = first anchor
        // p3 of last segment = last anchor
        // p3 of segment i (where i < numSegments-1) = middle anchor (shared with p0 of segment i+1)
        // p0 of segment i (where i > 0) = middle anchor (shared with p3 of segment i-1)

        if (numSegments === 1) {
          // Only one segment - delete it entirely
          state.segments = [];
          state.continuity = [];
          return;
        }

        if (pointType === 'p0' && segmentIndex === 0) {
          // Deleting FIRST anchor - remove first segment
          state.segments.shift();
          if (state.continuity.length > 0) {
            state.continuity.shift();
          }
          return;
        }

        if (pointType === 'p3' && segmentIndex === numSegments - 1) {
          // Deleting LAST anchor - remove last segment
          state.segments.pop();
          if (state.continuity.length > 0) {
            state.continuity.pop();
          }
          return;
        }

        // Deleting a MIDDLE anchor - merge two adjacent segments
        // The anchor at segmentIndex.p3 is also segmentIndex+1.p0
        let deleteIndex;
        if (pointType === 'p3') {
          deleteIndex = segmentIndex;
        } else {
          // pointType === 'p0' and segmentIndex > 0
          deleteIndex = segmentIndex - 1;
        }

        // Merge segment[deleteIndex] and segment[deleteIndex + 1]
        const seg1 = state.segments[deleteIndex];
        const seg2 = state.segments[deleteIndex + 1];

        // Create merged segment: keep p0, p1 from seg1 and p2, p3 from seg2
        const mergedSegment = {
          p0: { ...seg1.p0 },
          p1: { ...seg1.p1 },
          p2: { ...seg2.p2 },
          p3: { ...seg2.p3 },
        };

        // Replace seg1 with merged, remove seg2
        state.segments.splice(deleteIndex, 2, mergedSegment);

        // Remove one continuity entry (there's one less junction now)
        if (state.continuity.length > deleteIndex) {
          state.continuity.splice(deleteIndex, 1);
        }
      }

      // ========================================================================
      // DOM REFERENCES
      // ========================================================================

      const svg = document.getElementById("canvas");
      const curvesGroup = document.getElementById("curves");
      const handlesGroup = document.getElementById("handles");
      const pointsGroup = document.getElementById("points");
      const continuitySelect = document.getElementById("continuity");
      const clearBtn = document.getElementById("clearBtn");
      const exportBtn = document.getElementById("exportBtn");
      const segmentList = document.getElementById("segmentList");

      // ========================================================================
      // UTILS
      // ========================================================================

      function getMousePosition(event) {
        const rect = svg.getBoundingClientRect();
        return createPoint(event.clientX - rect.left, event.clientY - rect.top);
      }

      function createSvgElement(tag, attrs = {}) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (const [key, value] of Object.entries(attrs)) {
          el.setAttribute(key, value);
        }
        return el;
      }

      // ========================================================================
      // RENDERING
      // ========================================================================

      function render() {
        // Clear all groups
        curvesGroup.innerHTML = "";
        handlesGroup.innerHTML = "";
        pointsGroup.innerHTML = "";

        // Draw completed segments
        state.segments.forEach((seg, i) => {
          drawSegment(seg, i);
        });

        // Draw current segment being drawn
        if (state.currentSegment) {
          drawSegment(state.currentSegment, state.segments.length, true);
        }

        updateSegmentList();
      }

      function drawSegment(seg, index, isCurrentlyDrawing = false) {
        // Draw curve path
        const pathData = `M ${seg.p0.x} ${seg.p0.y} C ${seg.p1.x} ${seg.p1.y}, ${seg.p2.x} ${seg.p2.y}, ${seg.p3.x} ${seg.p3.y}`;
        const path = createSvgElement("path", {
          d: pathData,
          class: "curve-path",
          filter: "url(#glow)",
        });
        if (isCurrentlyDrawing) {
          path.style.opacity = "0.6";
        }
        curvesGroup.appendChild(path);

        // Draw handle lines
        const handleLine1 = createSvgElement("line", {
          x1: seg.p0.x,
          y1: seg.p0.y,
          x2: seg.p1.x,
          y2: seg.p1.y,
          class: "handle-line",
        });
        handlesGroup.appendChild(handleLine1);

        const handleLine2 = createSvgElement("line", {
          x1: seg.p3.x,
          y1: seg.p3.y,
          x2: seg.p2.x,
          y2: seg.p2.y,
          class: "handle-line",
        });
        handlesGroup.appendChild(handleLine2);

        // Draw control points (circles)
        const cp1 = createSvgElement("circle", {
          cx: seg.p1.x,
          cy: seg.p1.y,
          r: 6,
          class: "control-point",
          "data-segment": index,
          "data-point": "p1",
        });
        pointsGroup.appendChild(cp1);

        const cp2 = createSvgElement("circle", {
          cx: seg.p2.x,
          cy: seg.p2.y,
          r: 6,
          class: "control-point",
          "data-segment": index,
          "data-point": "p2",
        });
        pointsGroup.appendChild(cp2);

        // Draw anchor points (rectangles)
        // Only draw p0 for first segment or if not continuing from previous
        if (index === 0 || isCurrentlyDrawing) {
          const isStartSelected = state.activeEndpoint === 'start' && index === 0 && !isCurrentlyDrawing;
          const anchor0 = createSvgElement("rect", {
            x: seg.p0.x - 6,
            y: seg.p0.y - 6,
            width: 12,
            height: 12,
            class: "anchor-point" + (isStartSelected ? " endpoint-selected" : ""),
            "data-segment": index,
            "data-point": "p0",
          });
          pointsGroup.appendChild(anchor0);
        }

        // Always draw p3
        const isEndSelected = state.activeEndpoint === 'end' && index === state.segments.length - 1 && !isCurrentlyDrawing;
        const anchor3 = createSvgElement("rect", {
          x: seg.p3.x - 6,
          y: seg.p3.y - 6,
          width: 12,
          height: 12,
          class: "anchor-point" + (isEndSelected ? " endpoint-selected" : ""),
          "data-segment": index,
          "data-point": "p3",
        });
        pointsGroup.appendChild(anchor3);
      }

      function updateSegmentList() {
        if (state.segments.length === 0) {
          segmentList.innerHTML =
            '<div style="color: #666; font-size: 0.8rem;">No segments yet. Click to start drawing!</div>';
          return;
        }

        segmentList.innerHTML = state.segments
          .map((seg, i) => {
            const junctionMode = i > 0 ? state.continuity[i - 1] : null;
            return `
          <div class="segment-item">
            <div><strong>Segment ${i + 1}</strong></div>
            <div style="color: #888;">P₀: (${Math.round(seg.p0.x)}, ${Math.round(seg.p0.y)})</div>
            <div style="color: #888;">P₃: (${Math.round(seg.p3.x)}, ${Math.round(seg.p3.y)})</div>
            ${
              i > 0
                ? `
              <div class="junction-controls">
                <span style="color: #666; font-size: 0.7rem;">Junction:</span>
                <button class="junction-btn ${junctionMode === "independent" ? "active" : ""}" 
                        data-junction="${i - 1}" data-mode="independent">Indep</button>
                <button class="junction-btn ${junctionMode === "c1" ? "active" : ""}" 
                        data-junction="${i - 1}" data-mode="c1">C¹</button>
                <button class="junction-btn ${junctionMode === "c2" ? "active" : ""}" 
                        data-junction="${i - 1}" data-mode="c2">C²</button>
              </div>
            `
                : ""
            }
          </div>
        `;
          })
          .join("");

        // Add junction button listeners
        segmentList.querySelectorAll(".junction-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const junctionIndex = parseInt(e.target.dataset.junction);
            const mode = e.target.dataset.mode;
            setJunctionContinuity(junctionIndex, mode);
          });
        });
      }

      // ========================================================================
      // CONTINUITY ENFORCEMENT
      // ========================================================================

      function setJunctionContinuity(junctionIndex, mode) {
        state.continuity[junctionIndex] = mode;
        applyContinuity(junctionIndex);
        render();
      }

      function applyContinuity(junctionIndex) {
        const mode = state.continuity[junctionIndex];
        const prevSeg = state.segments[junctionIndex];
        const nextSeg = state.segments[junctionIndex + 1];

        if (!prevSeg || !nextSeg) return;

        let updated;
        switch (mode) {
          case "c1":
            updated = enforceC1(prevSeg, nextSeg);
            break;
          case "c2":
            updated = enforceC2(prevSeg, nextSeg);
            break;
          default:
            updated = enforceC0(prevSeg, nextSeg);
        }

        state.segments[junctionIndex + 1] = updated;
      }

      function applyAllContinuity() {
        for (let i = 0; i < state.continuity.length; i++) {
          applyContinuity(i);
        }
      }

      // Apply control point continuity when Ctrl+dragging
      // This mirrors the control point across the shared anchor
      function applyControlPointContinuity(segmentIndex, pointType, pos) {
        // p1 is outgoing control from p0 (shared with previous segment's p3)
        // p2 is incoming control to p3 (shared with next segment's p0)
        if (pointType === 'p1' && segmentIndex > 0) {
          // Mirror p1 movement to previous segment's p2
          const seg = state.segments[segmentIndex];
          const anchor = seg.p0; // This is also previous segment's p3
          const offset = subtractPoints(pos, anchor);
          state.segments[segmentIndex - 1].p2 = subtractPoints(anchor, offset);
        }
        if (pointType === 'p2' && segmentIndex < state.segments.length - 1) {
          // Mirror p2 movement to next segment's p1
          const seg = state.segments[segmentIndex];
          const anchor = seg.p3; // This is also next segment's p0
          const offset = subtractPoints(pos, anchor);
          state.segments[segmentIndex + 1].p1 = subtractPoints(anchor, offset);
        }
      }

      // ========================================================================
      // INTERACTION HANDLERS
      // ========================================================================

      function handleMouseDown(e) {
        const target = e.target;
        const pos = getMousePosition(e);

        // Reset drag tracking
        state.didDrag = false;
        state.dragStartPos = { ...pos };

        // Handle panning with space+drag or middle mouse button
        if (state.spacePressed || e.button === 1) {
          state.isPanning = true;
          state.panStart = { x: e.clientX, y: e.clientY };
          svg.style.cursor = 'grabbing';
          e.preventDefault();
          return;
        }

        // Check if clicking on an existing point
        if (
          target.classList.contains("anchor-point") ||
          target.classList.contains("control-point")
        ) {
          const segIndex = parseInt(target.dataset.segment);
          const pointType = target.dataset.point;

          // Ctrl+Click on anchor = delete node
          if ((e.ctrlKey || e.metaKey) && target.classList.contains("anchor-point")) {
            deleteNode(segIndex, pointType);
            state.activeEndpoint = null;
            render();
            return;
          }

          // Check if clicking on an endpoint (first or last anchor)
          const isFirstAnchor = pointType === 'p0' && segIndex === 0;
          const isLastAnchor = pointType === 'p3' && segIndex === state.segments.length - 1;

          // Start dragging - ALL points can be dragged including endpoints
          state.dragTarget = { segmentIndex: segIndex, pointType };
          
          // Track potential endpoint selection (will confirm on mouseUp if no drag)
          if (target.classList.contains("anchor-point") && (isFirstAnchor || isLastAnchor)) {
            state.potentialEndpointSelect = {
              segIndex,
              pointType,
              isFirst: isFirstAnchor,
            };
          } else {
            state.potentialEndpointSelect = null;
          }
          
          state.activeEndpoint = null; // Clear selection when starting to interact
          return;
        }

        // Clicking on canvas (not on a point)
        
        // Ctrl+click on canvas = extend from selected endpoint
        if ((e.ctrlKey || e.metaKey) && state.activeEndpoint && state.segments.length > 0) {
          // Extend from the selected endpoint
          if (state.activeEndpoint === 'start') {
            // Add segment at the beginning
            const existingStart = state.segments[0].p0;
            const newSegment = {
              p0: { ...pos },
              p1: { ...pos },
              p2: { ...existingStart },
              p3: { ...existingStart },
            };
            state.segments.unshift(newSegment);
            // Add continuity for the new junction (independent by default)
            state.continuity.unshift('independent');
          } else {
            // Add segment at the end
            const existingEnd = state.segments[state.segments.length - 1].p3;
            const newSegment = {
              p0: { ...existingEnd },
              p1: { ...existingEnd },
              p2: { ...pos },
              p3: { ...pos },
            };
            state.segments.push(newSegment);
            if (state.segments.length > 1) {
              state.continuity.push('independent');
            }
          }
          state.activeEndpoint = null;
          // Don't apply continuity - user controls this with Ctrl+drag
          render();
          return;
        }

        // Shift+click = start a completely new independent curve
        if (e.shiftKey) {
          state.currentSegment = {
            p0: { ...pos },
            p1: { ...pos },
            p2: { ...pos },
            p3: { ...pos },
          };
          state.isDrawing = true;
          state.activeEndpoint = null;
          render();
          return;
        }

        // Regular click = start drawing new segment continuing from last point
        if (!state.isDrawing) {
          const startPoint =
            state.segments.length > 0
              ? { ...state.segments[state.segments.length - 1].p3 }
              : pos;

          state.currentSegment = {
            p0: startPoint,
            p1: { ...startPoint },
            p2: { ...pos },
            p3: { ...pos },
          };
          state.isDrawing = true;
          state.activeEndpoint = null;
        }

        render();
      }

      function handleMouseMove(e) {
        // Handle panning
        if (state.isPanning) {
          const dx = e.clientX - state.panStart.x;
          const dy = e.clientY - state.panStart.y;
          
          // Move all points
          state.segments.forEach(seg => {
            seg.p0.x += dx;
            seg.p0.y += dy;
            seg.p1.x += dx;
            seg.p1.y += dy;
            seg.p2.x += dx;
            seg.p2.y += dy;
            seg.p3.x += dx;
            seg.p3.y += dy;
          });
          
          state.panStart = { x: e.clientX, y: e.clientY };
          render();
          return;
        }

        const pos = getMousePosition(e);

        // Handle dragging
        if (state.dragTarget) {
          const { segmentIndex, pointType } = state.dragTarget;
          const seg = state.segments[segmentIndex];

          // Track that we actually moved (for click vs drag detection)
          const dragDist = distance(pos, state.dragStartPos);
          if (dragDist > 3) {
            state.didDrag = true;
          }

          // For anchor points that are shared between segments
          if (pointType === "p0" && segmentIndex > 0) {
            // Also update previous segment's p3
            state.segments[segmentIndex - 1].p3 = { ...pos };
          }
          if (pointType === "p3" && segmentIndex < state.segments.length - 1) {
            // Also update next segment's p0
            state.segments[segmentIndex + 1].p0 = { ...pos };
          }

          seg[pointType] = { ...pos };

          // Only apply continuity when Ctrl is held (explicit control)
          if ((e.ctrlKey || e.metaKey) && (pointType === "p1" || pointType === "p2")) {
            applyControlPointContinuity(segmentIndex, pointType, pos);
          }

          // Don't auto-apply continuity when moving anchor points anymore
          // User has explicit control via Ctrl+drag on control points

          render();
          return;
        }

        // Handle drawing
        if (state.isDrawing && state.currentSegment) {
          // Update handles symmetrically while drawing
          const startPoint = state.currentSegment.p0;
          const handleOffset = subtractPoints(pos, startPoint);

          state.currentSegment.p1 = addPoints(startPoint, handleOffset);
          state.currentSegment.p2 = subtractPoints(
            pos,
            scalePoint(handleOffset, 0.3),
          );
          state.currentSegment.p3 = pos;

          render();
        }
      }

      function handleMouseUp(e) {
        // End panning
        if (state.isPanning) {
          state.isPanning = false;
          state.panStart = null;
          svg.style.cursor = state.spacePressed ? 'grab' : 'crosshair';
          return;
        }

        if (state.dragTarget) {
          // If we didn't drag much and it was an endpoint, select it
          if (state.potentialEndpointSelect && !state.didDrag) {
            const { isFirst } = state.potentialEndpointSelect;
            const clickedEndpoint = isFirst ? 'start' : 'end';
            // Toggle selection
            state.activeEndpoint = state.activeEndpoint === clickedEndpoint ? null : clickedEndpoint;
            render();
          }
          
          state.dragTarget = null;
          state.potentialEndpointSelect = null;
          state.didDrag = false;
          state.dragStartPos = null;
          return;
        }

        // Finish placing current segment
        if (state.isDrawing && state.currentSegment) {
          // New segments are independent by default - user controls continuity explicitly
          if (state.segments.length > 0) {
            state.continuity.push('independent');
          }

          state.segments.push(state.currentSegment);

          // Don't auto-apply continuity - user has explicit control
          state.currentSegment = null;
          state.isDrawing = false;

          render();
        }
      }

      function handleDoubleClick(e) {
        // Finish the current path
        state.isDrawing = false;
        state.currentSegment = null;
        render();
      }

      function handleClear() {
        state.segments = [];
        state.continuity = [];
        state.curves = [];
        state.activeCurveIndex = -1;
        state.isDrawing = false;
        state.currentSegment = null;
        state.dragTarget = null;
        state.activeEndpoint = null;
        state.potentialEndpointSelect = null;
        state.didDrag = false;
        state.dragStartPos = null;
        state.isPanning = false;
        state.panStart = null;
        render();
      }

      function handleExport() {
        const data = {
          segments: state.segments,
          continuity: state.continuity,
        };
        const json = JSON.stringify(data, null, 2);

        // Create download
        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "bezier-curves.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      // ========================================================================
      // EVENT LISTENERS
      // ========================================================================

      svg.addEventListener("mousedown", handleMouseDown);
      svg.addEventListener("mousemove", handleMouseMove);
      svg.addEventListener("mouseup", handleMouseUp);
      svg.addEventListener("dblclick", handleDoubleClick);
      svg.addEventListener("mouseleave", () => {
        if (state.dragTarget) {
          state.dragTarget = null;
        }
      });

      clearBtn.addEventListener("click", handleClear);
      exportBtn.addEventListener("click", handleExport);

      // Keyboard events for space+drag panning
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !state.spacePressed) {
          state.spacePressed = true;
          svg.style.cursor = 'grab';
          e.preventDefault();
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
          state.spacePressed = false;
          if (!state.isPanning) {
            svg.style.cursor = 'crosshair';
          }
        }
      });

      // Prevent context menu on middle click
      svg.addEventListener('contextmenu', (e) => {
        if (e.button === 1) e.preventDefault();
      });

      // Initial render
      render();
    </script>
  </body>
</html>
