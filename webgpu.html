<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>B√©zier Curve Editor - WebGPU</title>
    <link rel="stylesheet" href="common.css" />
    <style>
      /* WebGPU Editor Theme: Purple/Pink */
      :root {
        --theme-primary: #9b59b6;
        --theme-primary-rgb: 155, 89, 182;
        --theme-gradient: linear-gradient(90deg, #9b59b6, #e91e63);
        --theme-btn-primary: linear-gradient(135deg, #9b59b6, #8e44ad);
        --theme-btn-primary-text: #fff;
        /* Curve color: #00ffcc cyan */
      }

      #canvas {
        position: relative;
      }

      .webgpu-fallback {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.8);
        padding: 24px;
        border-radius: 12px;
        text-align: center;
        max-width: 400px;
      }

      .webgpu-fallback h2 {
        color: #e91e63;
        margin-bottom: 12px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>üîÆ B√©zier Curve Editor (WebGPU)</h1>
        <div class="toolbar">
          <div class="nav-links">
            <span>View in:</span>

            <a href="canvas.html" class="nav-link" id="navCanvas">Canvas</a>
            <a href="svg.html" class="nav-link" id="navSvg">SVG</a>
            <a href="html.html" class="nav-link" id="navHtml">HTML</a>
            <a href="webgl.html" class="nav-link" id="navWebgl">WebGL</a>
          </div>
          <div class="continuity-selector">
            <label for="continuity">Junction Mode:</label>
            <select id="continuity">
              <option value="independent">Independent</option>
              <option value="c1" selected>C¬π (Tangent)</option>
              <option value="c2">C¬≤ (Curvature)</option>
            </select>
          </div>
          <button class="btn-secondary" id="exportBtn">Export JSON</button>
          <button class="btn-secondary" id="copyUrlBtn">Copy URL</button>
          <button class="btn-danger" id="clearBtn">Clear All</button>
        </div>
      </header>

      <div class="main-content">
        <div class="canvas-container">
          <canvas id="canvas"></canvas>
          <div id="fallback" class="webgpu-fallback" style="display: none">
            <h2>WebGPU Not Available</h2>
            <hr />
            to test: <a href="https://webgpu.github.io/webgpu-samples/?sample=fractalCube" style="color: #8989b9;">https://webgpu.github.io/webgpu-samples/?sample=fractalCube</a> 
            <br />
            To enable go to chrome://flags/ and search for "webgpu" 
            <br />
            to test if enabled visit chrome://gpu/ and see if 
            <b></b>"WebGPU: Hardware accelerated</b> is green
          </div>
          <div class="instructions">
            <strong>Drag</strong> = move points freely<br />
            <strong>Ctrl+drag</strong> control point = maintain continuity<br />
            <strong>Shift+click</strong> = start new independent curve<br />
            <strong>Click endpoint</strong> then <strong>Ctrl+click</strong> canvas = extend<br />
            <strong>Ctrl+click</strong> anchor = delete ¬∑ <strong>Space+drag</strong> = pan
          </div>
          <div class="stats" id="stats">Curves: 0</div>
        </div>

        <div class="sidebar">
          <h3>How It Works</h3>
          <div class="info-box">
            <p>This renderer uses <code>WebGPU</code>!</p>
            <p style="margin-top: 8px">
              WebGPU is the next-generation GPU API with compute shader support and better performance than WebGL.
            </p>
          </div>

          <h3>Continuity Modes</h3>
          <div class="info-box">
            <p><code>C‚Å∞</code> - Points meet (always enforced)</p>
            <p><code>C¬π</code> - Smooth tangent (direction matches)</p>
            <p><code>C¬≤</code> - Smooth curvature (acceleration matches)</p>
          </div>

          <h3>Curves</h3>
          <div id="segmentList" class="segment-list">
            <div style="color: #666; font-size: 0.8rem">No curves yet. Shift+click to start drawing!</div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import { createPoint, addPoints, subtractPoints, scalePoint, distance } from "./bezier-math.js";
      import {
        serializeCurves,
        parseCurvesFromURL,
        debounce,
        deleteNodeFromCurves,
      } from "./common.js";

      // ============================================================================
      // WebGPU Setup
      // ============================================================================

      const canvas = document.getElementById("canvas");
      const fallback = document.getElementById("fallback");

      let device, context, format, pipeline, vertexBuffer, bindGroup, uniformBuffer;
      let webgpuReady = false;

      async function initWebGPU() {
        if (!navigator.gpu) {
          fallback.style.display = "block";
          console.warn("WebGPU not supported");
          return false;
        }

        try {
          const adapter = await navigator.gpu.requestAdapter();
          if (!adapter) {
            fallback.style.display = "block";
            return false;
          }

          device = await adapter.requestDevice();
          context = canvas.getContext("webgpu");
          format = navigator.gpu.getPreferredCanvasFormat();

          context.configure({
            device,
            format,
            alphaMode: "premultiplied",
          });

          // Create shader module
          const shaderModule = device.createShaderModule({
            code: `
              struct Uniforms {
                resolution: vec2f,
                pan: vec2f,
                color: vec4f,
              }

              @group(0) @binding(0) var<uniform> uniforms: Uniforms;

              struct VertexOutput {
                @builtin(position) position: vec4f,
              }

              @vertex
              fn vertexMain(@location(0) pos: vec2f) -> VertexOutput {
                var output: VertexOutput;
                let position = pos + uniforms.pan;
                let clipSpace = (position / uniforms.resolution) * 2.0 - 1.0;
                output.position = vec4f(clipSpace.x, -clipSpace.y, 0.0, 1.0);
                return output;
              }

              @fragment
              fn fragmentMain() -> @location(0) vec4f {
                return uniforms.color;
              }
            `,
          });

          // Create pipeline
          pipeline = device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module: shaderModule,
              entryPoint: "vertexMain",
              buffers: [
                {
                  arrayStride: 8,
                  attributes: [{ shaderLocation: 0, offset: 0, format: "float32x2" }],
                },
              ],
            },
            fragment: {
              module: shaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format }],
            },
            primitive: {
              topology: "line-strip",
            },
          });

          // Create uniform buffer
          uniformBuffer = device.createBuffer({
            size: 48, // 2 vec2 + 1 vec4 = 24 bytes, aligned to 48
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
          });

          // Create bind group
          bindGroup = device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
          });

          // Create vertex buffer
          vertexBuffer = device.createBuffer({
            size: 10000 * 8, // Max 10000 vertices
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });

          webgpuReady = true;
          return true;
        } catch (e) {
          console.error("WebGPU init failed:", e);
          fallback.style.display = "block";
          return false;
        }
      }

      // ============================================================================
      // State
      // ============================================================================

      let curves = [];
      let activeCurveIndex = -1;
      let selectedEndpoint = null;
      let dragging = null;
      let pan = { x: 0, y: 0 };
      let isPanning = false;
      let lastMouse = { x: 0, y: 0 };
      let spacePressed = false;

      const SEGMENTS_PER_CURVE = 50;

      // ============================================================================
      // B√©zier Math
      // ============================================================================

      function evaluateBezier(seg, t) {
        const mt = 1 - t;
        const mt2 = mt * mt;
        const mt3 = mt2 * mt;
        const t2 = t * t;
        const t3 = t2 * t;

        return {
          x: mt3 * seg.p0.x + 3 * mt2 * t * seg.p1.x + 3 * mt * t2 * seg.p2.x + t3 * seg.p3.x,
          y: mt3 * seg.p0.y + 3 * mt2 * t * seg.p1.y + 3 * mt * t2 * seg.p2.y + t3 * seg.p3.y,
        };
      }

      function tessellateSegment(seg, numPoints = SEGMENTS_PER_CURVE) {
        const points = [];
        for (let i = 0; i <= numPoints; i++) {
          const t = i / numPoints;
          points.push(evaluateBezier(seg, t));
        }
        return points;
      }

      // ============================================================================
      // WebGPU Drawing
      // ============================================================================

      function resizeCanvas() {
        const container = canvas.parentElement;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = container.clientWidth * dpr;
        canvas.height = container.clientHeight * dpr;
        canvas.style.width = container.clientWidth + "px";
        canvas.style.height = container.clientHeight + "px";
      }

      function drawWithWebGPU(allLines) {
        if (!webgpuReady || allLines.length === 0) return;

        const dpr = window.devicePixelRatio || 1;
        const encoder = device.createCommandEncoder();
        const textureView = context.getCurrentTexture().createView();

        const renderPass = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: textureView,
              clearValue: { r: 0.05, g: 0.07, b: 0.12, a: 1.0 },
              loadOp: "clear",
              storeOp: "store",
            },
          ],
        });

        renderPass.setPipeline(pipeline);
        renderPass.setBindGroup(0, bindGroup);

        // Draw each line batch
        for (const { points, color } of allLines) {
          if (points.length < 2) continue;

          const vertices = new Float32Array(points.length * 2);
          for (let i = 0; i < points.length; i++) {
            vertices[i * 2] = points[i].x * dpr;
            vertices[i * 2 + 1] = points[i].y * dpr;
          }

          device.queue.writeBuffer(vertexBuffer, 0, vertices);

          const uniforms = new Float32Array([
            canvas.width, canvas.height,
            pan.x * dpr, pan.y * dpr,
            color[0], color[1], color[2], color[3],
            0, 0, 0, 0, // padding
          ]);
          device.queue.writeBuffer(uniformBuffer, 0, uniforms);

          renderPass.setVertexBuffer(0, vertexBuffer);
          renderPass.draw(points.length);
        }

        renderPass.end();
        device.queue.submit([encoder.finish()]);
      }

      function render() {
        resizeCanvas();

        if (!webgpuReady) {
          // Fallback to 2D canvas
          const ctx = canvas.getContext("2d");
          if (ctx) {
            ctx.fillStyle = "#0d1120";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#fff";
            ctx.font = "16px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Loading WebGPU...", canvas.width / 2, canvas.height / 2);
          }
          return;
        }

        const allLines = [];
        const curveColor = [0.0, 1.0, 0.8, 1.0]; // #00ffcc
        const handleColor = [0.54, 0.36, 0.96, 0.6];

        // Collect curve lines
        for (const curve of curves) {
          for (const seg of curve.segments) {
            const points = tessellateSegment(seg);
            allLines.push({ points, color: curveColor });
            allLines.push({ points: [seg.p0, seg.p1], color: handleColor });
            allLines.push({ points: [seg.p2, seg.p3], color: handleColor });
          }
        }

        drawWithWebGPU(allLines);

        // Draw control points using 2D overlay (WebGPU point sprites are complex)
        const ctx2d = document.createElement("canvas").getContext("2d");
        // For simplicity, we'll just use the stats update
        
        updateStats();
        updateNavLinks();
      }

      // ============================================================================
      // Continuity Enforcement
      // ============================================================================

      function enforceContinuity(curveIndex, junctionIndex, movedControlPointType) {
        const curve = curves[curveIndex];
        if (!curve || junctionIndex < 0 || junctionIndex >= curve.continuity.length) return;

        const mode = curve.continuity[junctionIndex];
        if (mode === "independent") return;

        const seg1 = curve.segments[junctionIndex];
        const seg2 = curve.segments[junctionIndex + 1];
        const junction = seg1.p3;

        if (movedControlPointType === "p2") {
          const direction = subtractPoints(junction, seg1.p2);
          if (mode === "c1") {
            const len = distance(seg2.p1, junction);
            const normalized = scalePoint(direction, 1 / distance(seg1.p2, junction));
            seg2.p1 = addPoints(junction, scalePoint(normalized, len));
          } else if (mode === "c2") {
            seg2.p1 = addPoints(junction, direction);
          }
        } else if (movedControlPointType === "p1") {
          const direction = subtractPoints(junction, seg2.p1);
          if (mode === "c1") {
            const len = distance(seg1.p2, junction);
            const normalized = scalePoint(direction, 1 / distance(seg2.p1, junction));
            seg1.p2 = addPoints(junction, scalePoint(normalized, len));
          } else if (mode === "c2") {
            seg1.p2 = addPoints(junction, direction);
          }
        }
      }

      // ============================================================================
      // Hit Testing
      // ============================================================================

      function findPointAt(x, y, threshold = 10) {
        for (let ci = curves.length - 1; ci >= 0; ci--) {
          const curve = curves[ci];
          for (let si = curve.segments.length - 1; si >= 0; si--) {
            const seg = curve.segments[si];
            for (const type of ["p0", "p1", "p2", "p3"]) {
              if (type === "p0" && si > 0) continue;
              const p = seg[type];
              if (distance(p, { x, y }) <= threshold) {
                return { curveIndex: ci, segmentIndex: si, pointType: type };
              }
            }
          }
        }
        return null;
      }

      // ============================================================================
      // Mouse Handlers
      // ============================================================================

      function getMousePos(e) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left - pan.x,
          y: e.clientY - rect.top - pan.y,
        };
      }

      canvas.addEventListener("mousedown", (e) => {
        const pos = getMousePos(e);
        lastMouse = { x: e.clientX, y: e.clientY };

        if (spacePressed) {
          isPanning = true;
          return;
        }

        const hit = findPointAt(pos.x, pos.y);

        if (e.shiftKey && !hit) {
          const seg = {
            p0: createPoint(pos.x, pos.y),
            p1: createPoint(pos.x + 50, pos.y - 50),
            p2: createPoint(pos.x + 100, pos.y - 50),
            p3: createPoint(pos.x + 150, pos.y),
          };
          curves.push({ segments: [seg], continuity: [] });
          activeCurveIndex = curves.length - 1;
          selectedEndpoint = { curveIndex: activeCurveIndex, segmentIndex: 0, pointType: "p3" };
          updateURL();
          render();
          return;
        }

        if (e.ctrlKey && hit && (hit.pointType === "p0" || hit.pointType === "p3")) {
          const result = deleteNodeFromCurves(curves, activeCurveIndex, hit.curveIndex, hit.segmentIndex, hit.pointType);
          curves = result.curves;
          activeCurveIndex = result.activeCurveIndex;
          selectedEndpoint = null;
          updateURL();
          render();
          return;
        }

        if (e.ctrlKey && selectedEndpoint && !hit) {
          const ci = selectedEndpoint.curveIndex;
          const curve = curves[ci];
          const mode = document.getElementById("continuity").value;

          if (selectedEndpoint.pointType === "p3" && selectedEndpoint.segmentIndex === curve.segments.length - 1) {
            const lastSeg = curve.segments[curve.segments.length - 1];
            const dir = subtractPoints(lastSeg.p3, lastSeg.p2);
            const newSeg = {
              p0: { ...lastSeg.p3 },
              p1: addPoints(lastSeg.p3, dir),
              p2: { x: pos.x - 50, y: pos.y },
              p3: createPoint(pos.x, pos.y),
            };
            curve.segments.push(newSeg);
            curve.continuity.push(mode);
            selectedEndpoint = { curveIndex: ci, segmentIndex: curve.segments.length - 1, pointType: "p3" };
          } else if (selectedEndpoint.pointType === "p0" && selectedEndpoint.segmentIndex === 0) {
            const firstSeg = curve.segments[0];
            const dir = subtractPoints(firstSeg.p0, firstSeg.p1);
            const newSeg = {
              p0: createPoint(pos.x, pos.y),
              p1: { x: pos.x + 50, y: pos.y },
              p2: addPoints(firstSeg.p0, dir),
              p3: { ...firstSeg.p0 },
            };
            curve.segments.unshift(newSeg);
            curve.continuity.unshift(mode);
            selectedEndpoint = { curveIndex: ci, segmentIndex: 0, pointType: "p0" };
          }
          updateURL();
          render();
          return;
        }

        if (hit) {
          dragging = hit;
          activeCurveIndex = hit.curveIndex;
          if (hit.pointType === "p0" || hit.pointType === "p3") {
            const isEndpoint =
              (hit.pointType === "p0" && hit.segmentIndex === 0) ||
              (hit.pointType === "p3" && hit.segmentIndex === curves[hit.curveIndex].segments.length - 1);
            if (isEndpoint) {
              selectedEndpoint = hit;
            }
          }
          render();
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isPanning) {
          pan.x += e.clientX - lastMouse.x;
          pan.y += e.clientY - lastMouse.y;
          lastMouse = { x: e.clientX, y: e.clientY };
          render();
          return;
        }

        if (!dragging) return;

        const pos = getMousePos(e);
        const curve = curves[dragging.curveIndex];
        const seg = curve.segments[dragging.segmentIndex];
        const oldPos = { ...seg[dragging.pointType] };
        seg[dragging.pointType] = pos;

        if (dragging.pointType === "p0" || dragging.pointType === "p3") {
          const delta = subtractPoints(pos, oldPos);
          
          if (dragging.pointType === "p0") {
            seg.p1 = addPoints(seg.p1, delta);
            if (dragging.segmentIndex > 0) {
              const prevSeg = curve.segments[dragging.segmentIndex - 1];
              prevSeg.p3 = { ...pos };
              prevSeg.p2 = addPoints(prevSeg.p2, delta);
            }
          } else {
            seg.p2 = addPoints(seg.p2, delta);
            if (dragging.segmentIndex < curve.segments.length - 1) {
              const nextSeg = curve.segments[dragging.segmentIndex + 1];
              nextSeg.p0 = { ...pos };
              nextSeg.p1 = addPoints(nextSeg.p1, delta);
            }
          }
        } else if (e.ctrlKey) {
          if (dragging.pointType === "p2" && dragging.segmentIndex < curve.segments.length - 1) {
            enforceContinuity(dragging.curveIndex, dragging.segmentIndex, "p2");
          } else if (dragging.pointType === "p1" && dragging.segmentIndex > 0) {
            enforceContinuity(dragging.curveIndex, dragging.segmentIndex - 1, "p1");
          }
        }

        render();
      });

      canvas.addEventListener("mouseup", () => {
        if (dragging) {
          updateURL();
        }
        dragging = null;
        isPanning = false;
      });

      canvas.addEventListener("mouseleave", () => {
        dragging = null;
        isPanning = false;
      });

      // ============================================================================
      // Keyboard
      // ============================================================================

      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" && !e.repeat) {
          spacePressed = true;
          canvas.style.cursor = "grab";
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          spacePressed = false;
          canvas.style.cursor = "crosshair";
        }
      });

      // ============================================================================
      // URL & UI
      // ============================================================================

      const updateURL = debounce(() => {
        const hash = serializeCurves(curves);
        window.history.replaceState(null, "", hash ? "#" + hash : window.location.pathname);
        updateSegmentList();
      }, 100);

      function updateNavLinks() {
        const hash = serializeCurves(curves);
        const hashStr = hash ? "#" + hash : "";
        document.getElementById("navCanvas").href = "canvas.html" + hashStr;
        document.getElementById("navSvg").href = "svg.html" + hashStr;
        document.getElementById("navHtml").href = "html.html" + hashStr;
        document.getElementById("navWebgl").href = "webgl.html" + hashStr;
      }

      function updateStats() {
        const totalSegments = curves.reduce((sum, c) => sum + c.segments.length, 0);
        document.getElementById("stats").textContent = `Curves: ${curves.length} | Segments: ${totalSegments}`;
      }

      function updateSegmentList() {
        const list = document.getElementById("segmentList");
        if (curves.length === 0) {
          list.innerHTML = '<div style="color: #666; font-size: 0.8rem">No curves yet. Shift+click to start!</div>';
          return;
        }
        list.innerHTML = curves
          .map(
            (curve, i) => `
          <div class="segment-item${i === activeCurveIndex ? " selected" : ""}">
            <strong>Curve ${i + 1}</strong>: ${curve.segments.length} segment(s)
          </div>
        `
          )
          .join("");
      }

      // ============================================================================
      // Buttons
      // ============================================================================

      document.getElementById("clearBtn").addEventListener("click", () => {
        curves = [];
        activeCurveIndex = -1;
        selectedEndpoint = null;
        updateURL();
        render();
      });

      document.getElementById("exportBtn").addEventListener("click", () => {
        const data = JSON.stringify(curves, null, 2);
        const blob = new Blob([data], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "bezier-curves.json";
        a.click();
        URL.revokeObjectURL(url);
      });

      document.getElementById("copyUrlBtn").addEventListener("click", () => {
        navigator.clipboard.writeText(window.location.href);
      });

      // ============================================================================
      // Init
      // ============================================================================

      async function init() {
        const hash = window.location.hash.slice(1);
        if (hash) {
          curves = parseCurvesFromURL(hash);
          if (curves.length > 0) activeCurveIndex = 0;
        }
        
        resizeCanvas();
        await initWebGPU();
        render();
      }

      window.addEventListener("resize", render);
      window.addEventListener("hashchange", () => {
        curves = parseCurvesFromURL(window.location.hash.slice(1));
        if (curves.length > 0) activeCurveIndex = 0;
        render();
      });

      init();
    </script>
  </body>
</html>
