<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>B√©zier Curve Editor - Canvas</title>
    <link rel="stylesheet" href="common.css" />
    <style>
      /* Canvas Editor Theme: Green/Coral */
      :root {
        --theme-primary: #ff6b6b;
        --theme-primary-rgb: 255, 107, 107;
        --theme-gradient: linear-gradient(90deg, #ff6b6b, #ffa502);
        --theme-btn-primary: linear-gradient(135deg, #ff6b6b, #ee5a24);
        --theme-btn-primary-text: #fff;
        /* Curve color (used in JS): #00ff88 green */
      }

      /* Canvas-specific positioning */
      #canvas {
        position: relative;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>üé® B√©zier Curve Editor (Canvas)</h1>
        <div class="toolbar">
          <div class="nav-links">
            <span>View in:</span>
            <a
              href="canvas.html#508~190.5_334~325.5_199~272.5_439~91.5!371~220.5_583~49.5_613~126.5_498~278.5-i498~278.5_643~206.5_673~290.5_622~328.5!582~283.5_468~373.5_595~421.5_663~374.5"
              class="nav-link"
              onclick="
                location.href = this.href;
                location.reload();
                return false;
              "
              >Example</a
            >
            <a href="svg.html" class="nav-link" id="navSvg">SVG</a>
            <a href="html.html" class="nav-link" id="navHtml">HTML</a>
            <a href="webgl.html" class="nav-link" id="navWebgl">WebGL</a>
            <a href="webgpu.html" class="nav-link" id="navWebgpu">WebGPU</a>
          </div>
          <div class="continuity-selector">
            <label for="continuity">Junction Mode:</label>
            <select id="continuity">
              <option value="independent">Independent</option>
              <option value="c1" selected>C¬π (Tangent)</option>
              <option value="c2">C¬≤ (Curvature)</option>
            </select>
          </div>
          <button class="btn-secondary" id="exportBtn">Export JSON</button>
          <button class="btn-secondary" id="copyUrlBtn">Copy URL</button>
          <button class="btn-danger" id="clearBtn">Clear All</button>
        </div>
      </header>

      <div class="main-content">
        <div class="canvas-container">
          <canvas id="canvas"></canvas>
          <div class="instructions">
            <strong>Drag</strong> = move points freely<br />
            <strong>Ctrl+drag</strong> control point = maintain continuity<br />
            <strong>Shift+click</strong> = start new independent curve<br />
            <strong>Click endpoint</strong> then <strong>Ctrl+click</strong> canvas = extend<br />
            <strong>Ctrl+click</strong> anchor = delete ¬∑ <strong>Space+drag</strong> = pan
          </div>
          <div class="stats" id="stats">Curves: 0</div>
        </div>

        <div class="sidebar">
          <h3>How It Works</h3>
          <div class="info-box">
            <p>This renderer uses the <code>&lt;canvas&gt;</code> element!</p>
            <p style="margin-top: 8px">
              Curves are drawn using the Canvas 2D API with bezierCurveTo() for smooth rendering.
            </p>
          </div>

          <h3>Continuity Modes</h3>
          <div class="info-box">
            <p><code>C‚Å∞</code> - Points meet (always enforced)</p>
            <p><code>C¬π</code> - Smooth tangent (direction matches)</p>
            <p><code>C¬≤</code> - Smooth curvature (acceleration matches)</p>
          </div>

          <h3>Curves</h3>
          <div id="segmentList" class="segment-list">
            <div style="color: #666; font-size: 0.8rem">No curves yet. Shift+click to start drawing!</div>
          </div>
        </div>
      </div>
    </div>

    <script type="module">
      import { createPoint, addPoints, subtractPoints, scalePoint, distance } from "./bezier-math.js";
      import {
        serializeCurves,
        parseCurvesFromURL,
        deleteNodeFromCurves,
        debounce,
      } from "./common.js";

      // ========================================================================
      // STATE
      // ========================================================================

      const state = {
        curves: [],
        activeCurveIndex: -1,
        isDrawing: false,
        currentSegment: null,
        currentCurveIndex: -1,
        dragTarget: null,
        activeEndpoint: null,
        potentialEndpointSelect: null,
        didDrag: false,
        dragStartPos: null,
        isPanning: false,
        panStart: null,
        spacePressed: false,
        canvasFocused: true,
      };

      // ========================================================================
      // URL SERIALIZATION (uses common.js)
      // ========================================================================

      function updateURLHash() {
        const serialized = serializeCurves(state.curves);
        if (serialized) {
          window.history.replaceState(null, "", "#" + serialized);
        } else {
          window.history.replaceState(null, "", window.location.pathname);
        }
        updateNavLinks();
      }

      function updateNavLinks() {
        const hash = serializeCurves(state.curves);
        const hashStr = hash ? "#" + hash : "";
        document.getElementById("navSvg").href = "svg.html" + hashStr;
        document.getElementById("navHtml").href = "html.html" + hashStr;
        document.getElementById("navWebgl").href = "webgl.html" + hashStr;
        document.getElementById("navWebgpu").href = "webgpu.html" + hashStr;
      }

      function loadFromURLHash() {
        const hash = window.location.hash.slice(1);
        if (hash) {
          try {
            const curves = parseCurvesFromURL(hash);
            if (curves.length > 0) {
              state.curves = curves;
              return true;
            }
          } catch (e) {
            console.warn("Failed to parse URL hash:", e);
          }
        }
        return false;
      }

      const debouncedUpdateURLHash = debounce(updateURLHash, 300);

      // ========================================================================
      // NODE DELETION (uses common.js)
      // ========================================================================

      function deleteNode(curveIndex, segmentIndex, pointType) {
        const result = deleteNodeFromCurves(
          state.curves,
          state.activeCurveIndex,
          curveIndex,
          segmentIndex,
          pointType
        );
        state.curves = result.curves;
        state.activeCurveIndex = result.activeCurveIndex;
      }

      // ========================================================================
      // DOM REFERENCES
      // ========================================================================

      const canvasEl = document.getElementById("canvas");
      const ctx = canvasEl.getContext("2d");
      const canvasContainer = canvasEl.parentElement;
      const continuitySelect = document.getElementById("continuity");
      const clearBtn = document.getElementById("clearBtn");
      const exportBtn = document.getElementById("exportBtn");
      const copyUrlBtn = document.getElementById("copyUrlBtn");
      const segmentList = document.getElementById("segmentList");
      const statsEl = document.getElementById("stats");

      // ========================================================================
      // CANVAS SETUP
      // ========================================================================

      function resizeCanvas() {
        const rect = canvasContainer.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvasEl.width = rect.width * dpr;
        canvasEl.height = rect.height * dpr;
        canvasEl.style.width = rect.width + "px";
        canvasEl.style.height = rect.height + "px";
        ctx.scale(dpr, dpr);
        render();
      }

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      // ========================================================================
      // UTILS
      // ========================================================================

      function getMousePosition(event) {
        const rect = canvasEl.getBoundingClientRect();
        return createPoint(event.clientX - rect.left, event.clientY - rect.top);
      }

      function findPointAt(pos, radius = 10) {
        for (let curveIndex = state.curves.length - 1; curveIndex >= 0; curveIndex--) {
          const curve = state.curves[curveIndex];
          for (let segIndex = curve.segments.length - 1; segIndex >= 0; segIndex--) {
            const seg = curve.segments[segIndex];
            const totalSegments = curve.segments.length;

            // Check anchor points
            if (distance(pos, seg.p3) < radius) {
              return { curveIndex, segmentIndex: segIndex, pointType: "p3", isAnchor: true };
            }
            if (segIndex === 0 && distance(pos, seg.p0) < radius) {
              return { curveIndex, segmentIndex: segIndex, pointType: "p0", isAnchor: true };
            }

            // Check control points (only when focused)
            if (state.canvasFocused) {
              if (distance(pos, seg.p2) < radius) {
                return { curveIndex, segmentIndex: segIndex, pointType: "p2", isAnchor: false };
              }
              if (distance(pos, seg.p1) < radius) {
                return { curveIndex, segmentIndex: segIndex, pointType: "p1", isAnchor: false };
              }
            }
          }
        }
        return null;
      }

      // ========================================================================
      // RENDERING
      // ========================================================================

      function render() {
        const rect = canvasContainer.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);

        // Draw all curves
        state.curves.forEach((curve, curveIndex) => {
          drawCurve(curve, curveIndex);
        });

        // Draw current segment being drawn
        if (state.currentSegment) {
          drawSegment(state.currentSegment, state.currentCurveIndex, -1, 0, true);
        }

        // Update stats
        const totalSegs = state.curves.reduce((sum, c) => sum + c.segments.length, 0);
        statsEl.textContent = `Curves: ${state.curves.length} | Segments: ${totalSegs}`;

        updateSegmentList();
        updateNavLinks();

        if (!state.isDrawing) {
          debouncedUpdateURLHash();
        }
      }

      function drawCurve(curve, curveIndex) {
        curve.segments.forEach((seg, segIndex) => {
          drawSegment(seg, curveIndex, segIndex, curve.segments.length);
        });
      }

      function drawSegment(seg, curveIndex, segIndex, totalSegments, isCurrentlyDrawing = false) {
        // Draw curve path
        ctx.beginPath();
        ctx.moveTo(seg.p0.x, seg.p0.y);
        ctx.bezierCurveTo(seg.p1.x, seg.p1.y, seg.p2.x, seg.p2.y, seg.p3.x, seg.p3.y);

        const gradient = ctx.createLinearGradient(seg.p0.x, seg.p0.y, seg.p3.x, seg.p3.y);
        gradient.addColorStop(0, "#22c55e");
        gradient.addColorStop(1, "#16a34a");

        ctx.strokeStyle = gradient;
        ctx.lineWidth = 3;
        ctx.lineCap = "round";
        ctx.globalAlpha = isCurrentlyDrawing ? 0.6 : 1;
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Only draw handles and points if canvas is focused
        if (!state.canvasFocused) return;

        // Draw handle lines (dashed)
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = "rgba(139, 92, 246, 0.5)";
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(seg.p0.x, seg.p0.y);
        ctx.lineTo(seg.p1.x, seg.p1.y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(seg.p3.x, seg.p3.y);
        ctx.lineTo(seg.p2.x, seg.p2.y);
        ctx.stroke();

        ctx.setLineDash([]);

        // Draw control points (circles)
        drawControlPoint(seg.p1);
        drawControlPoint(seg.p2);

        // Draw anchor points (squares)
        if (segIndex === 0 || isCurrentlyDrawing) {
          const isStartSelected =
            state.activeEndpoint &&
            state.activeEndpoint.curveIndex === curveIndex &&
            state.activeEndpoint.end === "start" &&
            segIndex === 0 &&
            !isCurrentlyDrawing;
          drawAnchorPoint(seg.p0, isStartSelected);
        }

        const isEndSelected =
          state.activeEndpoint &&
          state.activeEndpoint.curveIndex === curveIndex &&
          state.activeEndpoint.end === "end" &&
          segIndex === totalSegments - 1 &&
          !isCurrentlyDrawing;
        drawAnchorPoint(seg.p3, isEndSelected);
      }

      function drawControlPoint(p) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = "#8b5cf6";
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function drawAnchorPoint(p, isSelected = false) {
        const size = 7;
        ctx.fillStyle = isSelected ? "#00d9ff" : "#22c55e";
        ctx.fillRect(p.x - size, p.y - size, size * 2, size * 2);
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x - size, p.y - size, size * 2, size * 2);
      }

      function updateSegmentList() {
        if (state.curves.length === 0) {
          segmentList.innerHTML =
            '<div style="color: #666; font-size: 0.8rem;">No curves yet. Shift+click to start drawing!</div>';
          return;
        }

        let html = "";
        state.curves.forEach((curve, curveIndex) => {
          html += `<div style="margin-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;">
          <div style="color: #22c55e; font-weight: bold; margin-bottom: 6px;">Curve ${curveIndex + 1}</div>`;
          curve.segments.forEach((seg, i) => {
            html += `
            <div class="segment-item">
              <div><strong>Seg ${i + 1}</strong></div>
              <div style="color: #888;">P‚ÇÄ: (${Math.round(seg.p0.x)}, ${Math.round(seg.p0.y)})</div>
              <div style="color: #888;">P‚ÇÉ: (${Math.round(seg.p3.x)}, ${Math.round(seg.p3.y)})</div>
            </div>
          `;
          });
          html += "</div>";
        });
        segmentList.innerHTML = html;
      }

      // ========================================================================
      // CONTINUITY ENFORCEMENT
      // ========================================================================

      function applyControlPointContinuity(curveIndex, segmentIndex, pointType, pos) {
        if (curveIndex < 0 || curveIndex >= state.curves.length) return;
        const curve = state.curves[curveIndex];

        if (pointType === "p1" && segmentIndex > 0) {
          const seg = curve.segments[segmentIndex];
          const anchor = seg.p0;
          const offset = subtractPoints(pos, anchor);
          curve.segments[segmentIndex - 1].p2 = subtractPoints(anchor, offset);
        }
        if (pointType === "p2" && segmentIndex < curve.segments.length - 1) {
          const seg = curve.segments[segmentIndex];
          const anchor = seg.p3;
          const offset = subtractPoints(pos, anchor);
          curve.segments[segmentIndex + 1].p1 = subtractPoints(anchor, offset);
        }
      }

      // ========================================================================
      // INTERACTION HANDLERS
      // ========================================================================

      function handleMouseDown(e) {
        const pos = getMousePosition(e);

        state.didDrag = false;
        state.dragStartPos = { ...pos };

        // Space+drag = pan
        if (state.spacePressed || e.button === 1) {
          state.isPanning = true;
          state.panStart = { x: e.clientX, y: e.clientY };
          canvasEl.style.cursor = "grabbing";
          e.preventDefault();
          return;
        }

        // Check if clicking on an existing point
        const hit = findPointAt(pos);

        if (hit) {
          const { curveIndex, segmentIndex, pointType, isAnchor } = hit;

          if (curveIndex < 0 || curveIndex >= state.curves.length) return;

          const curve = state.curves[curveIndex];

          // Ctrl+click anchor = delete
          if ((e.ctrlKey || e.metaKey) && isAnchor) {
            deleteNode(curveIndex, segmentIndex, pointType);
            state.activeEndpoint = null;
            render();
            return;
          }

          // Start dragging
          const isFirstAnchor = pointType === "p0" && segmentIndex === 0;
          const isLastAnchor = pointType === "p3" && segmentIndex === curve.segments.length - 1;

          state.dragTarget = { curveIndex, segmentIndex, pointType };

          if (isAnchor && (isFirstAnchor || isLastAnchor)) {
            state.potentialEndpointSelect = {
              curveIndex,
              segIndex: segmentIndex,
              pointType,
              isFirst: isFirstAnchor,
            };
          } else {
            state.potentialEndpointSelect = null;
          }

          state.activeEndpoint = null;
          return;
        }

        // Ctrl+click on canvas = extend from selected endpoint
        if ((e.ctrlKey || e.metaKey) && state.activeEndpoint) {
          const { curveIndex, end } = state.activeEndpoint;
          if (curveIndex >= 0 && curveIndex < state.curves.length) {
            const curve = state.curves[curveIndex];

            if (end === "start") {
              const existingStart = curve.segments[0].p0;
              const newSegment = {
                p0: { ...pos },
                p1: { ...pos },
                p2: { ...existingStart },
                p3: { ...existingStart },
              };
              curve.segments.unshift(newSegment);
              curve.continuity.unshift("independent");
            } else {
              const existingEnd = curve.segments[curve.segments.length - 1].p3;
              const newSegment = {
                p0: { ...existingEnd },
                p1: { ...existingEnd },
                p2: { ...pos },
                p3: { ...pos },
              };
              curve.segments.push(newSegment);
              if (curve.segments.length > 1) {
                curve.continuity.push("independent");
              }
            }
            state.activeEndpoint = null;
            render();
            return;
          }
        }

        // Shift+click = start new curve
        if (e.shiftKey) {
          const newCurveIndex = state.curves.length;
          state.curves.push({ segments: [], continuity: [] });
          state.currentCurveIndex = newCurveIndex;

          state.currentSegment = {
            p0: { ...pos },
            p1: { ...pos },
            p2: { ...pos },
            p3: { ...pos },
          };
          state.isDrawing = true;
          state.activeEndpoint = null;
          render();
          return;
        }

        // Regular click = clear endpoint selection
        state.activeEndpoint = null;
        render();
      }

      function handleMouseMove(e) {
        if (state.isPanning) {
          const dx = e.clientX - state.panStart.x;
          const dy = e.clientY - state.panStart.y;

          state.curves.forEach((curve) => {
            curve.segments.forEach((seg) => {
              seg.p0.x += dx;
              seg.p0.y += dy;
              seg.p1.x += dx;
              seg.p1.y += dy;
              seg.p2.x += dx;
              seg.p2.y += dy;
              seg.p3.x += dx;
              seg.p3.y += dy;
            });
          });

          state.panStart = { x: e.clientX, y: e.clientY };
          render();
          return;
        }

        const pos = getMousePosition(e);

        if (state.dragTarget) {
          const { curveIndex, segmentIndex, pointType } = state.dragTarget;

          if (curveIndex < 0 || curveIndex >= state.curves.length) {
            state.dragTarget = null;
            return;
          }

          const curve = state.curves[curveIndex];
          const seg = curve.segments[segmentIndex];

          if (!seg) {
            state.dragTarget = null;
            return;
          }

          const dragDist = distance(pos, state.dragStartPos);
          if (dragDist > 3) {
            state.didDrag = true;
          }

          // Update shared anchors
          if (pointType === "p0" && segmentIndex > 0) {
            curve.segments[segmentIndex - 1].p3 = { ...pos };
          }
          if (pointType === "p3" && segmentIndex < curve.segments.length - 1) {
            curve.segments[segmentIndex + 1].p0 = { ...pos };
          }

          seg[pointType] = { ...pos };

          // Ctrl+drag control point = maintain continuity
          if ((e.ctrlKey || e.metaKey) && (pointType === "p1" || pointType === "p2")) {
            applyControlPointContinuity(curveIndex, segmentIndex, pointType, pos);
          }

          render();
          return;
        }

        if (state.isDrawing && state.currentSegment) {
          const startPoint = state.currentSegment.p0;
          const handleOffset = subtractPoints(pos, startPoint);

          state.currentSegment.p1 = addPoints(startPoint, handleOffset);
          state.currentSegment.p2 = subtractPoints(pos, scalePoint(handleOffset, 0.3));
          state.currentSegment.p3 = pos;

          render();
        }
      }

      function handleMouseUp(e) {
        if (state.isPanning) {
          state.isPanning = false;
          state.panStart = null;
          canvasEl.style.cursor = state.spacePressed ? "grab" : "crosshair";
          return;
        }

        if (state.dragTarget) {
          if (state.potentialEndpointSelect && !state.didDrag) {
            const { curveIndex, isFirst } = state.potentialEndpointSelect;
            const clickedEndpoint = { curveIndex, end: isFirst ? "start" : "end" };

            if (
              state.activeEndpoint &&
              state.activeEndpoint.curveIndex === clickedEndpoint.curveIndex &&
              state.activeEndpoint.end === clickedEndpoint.end
            ) {
              state.activeEndpoint = null;
            } else {
              state.activeEndpoint = clickedEndpoint;
            }
            render();
          }

          state.dragTarget = null;
          state.potentialEndpointSelect = null;
          state.didDrag = false;
          state.dragStartPos = null;
          return;
        }

        if (state.isDrawing && state.currentSegment) {
          const curveIndex = state.currentCurveIndex;

          if (curveIndex >= 0 && curveIndex < state.curves.length) {
            const curve = state.curves[curveIndex];

            if (curve.segments.length > 0) {
              curve.continuity.push("independent");
            }

            curve.segments.push(state.currentSegment);
          }

          state.currentSegment = null;
          state.isDrawing = false;

          render();
        }
      }

      function handleDoubleClick(e) {
        state.isDrawing = false;
        state.currentSegment = null;
        render();
      }

      function handleClear() {
        state.curves = [];
        state.activeCurveIndex = -1;
        state.isDrawing = false;
        state.currentSegment = null;
        state.currentCurveIndex = -1;
        state.dragTarget = null;
        state.activeEndpoint = null;
        render();
      }

      function handleExport() {
        const data = { curves: state.curves };
        const json = JSON.stringify(data, null, 2);

        const blob = new Blob([json], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "bezier-curves.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      function handleCopyUrl() {
        const serialized = serializeToURL();
        if (!serialized) {
          alert("No curves to share!");
          return;
        }
        const fullUrl = window.location.origin + window.location.pathname + "#" + serialized;
        navigator.clipboard
          .writeText(fullUrl)
          .then(() => {
            const originalText = copyUrlBtn.textContent;
            copyUrlBtn.textContent = "Copied!";
            setTimeout(() => {
              copyUrlBtn.textContent = originalText;
            }, 1500);
          })
          .catch((err) => {
            console.error("Failed to copy URL:", err);
            prompt("Copy this URL:", fullUrl);
          });
      }

      // ========================================================================
      // EVENT LISTENERS
      // ========================================================================

      canvasEl.addEventListener("mousedown", handleMouseDown);
      canvasEl.addEventListener("mousemove", handleMouseMove);
      canvasEl.addEventListener("mouseup", handleMouseUp);
      canvasEl.addEventListener("dblclick", handleDoubleClick);
      canvasEl.addEventListener("mouseleave", () => {
        if (state.dragTarget) {
          state.dragTarget = null;
        }
      });

      clearBtn.addEventListener("click", handleClear);
      exportBtn.addEventListener("click", handleExport);
      copyUrlBtn.addEventListener("click", handleCopyUrl);

      // Keyboard events
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" && !state.spacePressed) {
          state.spacePressed = true;
          canvasEl.style.cursor = "grab";
          e.preventDefault();
        }
        if (e.code === "Escape" && state.canvasFocused) {
          state.canvasFocused = false;
          render();
        }
      });

      document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
          state.spacePressed = false;
          if (!state.isPanning) {
            canvasEl.style.cursor = "crosshair";
          }
        }
      });

      // Prevent context menu on canvas
      canvasEl.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });

      // Canvas focus/unfocus
      document.addEventListener("mousedown", (e) => {
        const clickedOnCanvas = canvasEl.contains(e.target);
        if (clickedOnCanvas && !state.canvasFocused) {
          state.canvasFocused = true;
          render();
        } else if (!clickedOnCanvas && state.canvasFocused) {
          const isToolbarClick = e.target.closest(".toolbar") || e.target.closest(".sidebar");
          if (!isToolbarClick) {
            state.canvasFocused = false;
            render();
          }
        }
      });

      // Load from URL hash if present
      loadFromURLHash();
      updateNavLinks();

      // Initial render
      render();
    </script>
  </body>
</html>
